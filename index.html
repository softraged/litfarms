<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  <title>LitFarms Product List</title>
  <!-- Replace favicon with inline SVG -->
  <link rel="icon" href="data:image/svg+xml,<?xml version='1.0' encoding='UTF-8' standalone='no'?><svg width='4.6079073in' height='2.5213542in' viewBox='0 0 117.04084 64.042396' version='1.1' id='svg1' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'><defs id='defs1'/><g id='layer1' transform='translate(-46.479583,-116.4788)'><rect style='display:inline;opacity:1;fill:none;fill-opacity:1;stroke:%23ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1' id='rect2' width='111.04084' height='58.0424' x='49.47958' y='119.4788'/><g id='g6' style='opacity:1;fill:%23ffffff;fill-opacity:1' transform='matrix(1,0,0,1.0224587,0.56861157,30.651474)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1' id='rect5' width='25.801872' height='5.860003' x='119.94384' y='98.674728' ry='0'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1' id='rect6' width='6' height='30.334635' x='130.05539' y='101.46412'/></g><path style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1' d='m 100.03961,131.46649 h 6 v 33.97218 h -6 z' id='path4'/><g id='g9' transform='matrix(1,0,0,1.0199169,-0.14807164,31.087934)'><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1' id='rect8' width='6' height='33.229393' x='64.364632' y='98.429321'/><rect style='opacity:1;fill:%23ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1' id='rect9' width='21.184687' height='5.8828321' x='64.373192' y='125.75582'/></g></g></svg>">
  <link rel="stylesheet" href="style.css">
  <style>
  
  </style>
  
</head>
<body>
  <div id="site-status" class="site-status">
    <span id="status-message"></span>
    <button id="retry-button" class="retry-button" style="display: none;">Retry Now</button>
  </div>
  

  <div class="filters-container" id="filters-container" style="width:75%; margin: 0 auto;">
  <button id="filter-toggle-button" aria-expanded="true" aria-controls="filters-content">
        Hide Filters
        <svg id="filter-toggle-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <polyline points="6 9 12 15 18 9"></polyline>
        </svg>
    </button>
  <div id="filterstohide">
  <div class="header">
  
    <a href="https://www.litfarms.com" class="header-link" style="margin-left: auto;margin-right: 3px; margin-bottom:3px;">
      <svg width="65" height="65" viewBox="0 0 117.04084 64.042396" version="1.1" id="svg1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg">
        <defs id="defs1"></defs>
        <g id="layer1" transform="translate(-46.479583,-116.4788)">
          <rect style="display:inline;opacity:1;fill:none;fill-opacity:1;stroke:#ffffff;stroke-width:6;stroke-dasharray:none;stroke-opacity:1" id="rect2" width="111.04084" height="58.0424" x="49.47958" y="119.4788"></rect>
          <g id="g6" style="opacity:1;fill:#ffffff;fill-opacity:1" transform="matrix(1,0,0,1.0224587,0.56861157,30.651474)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.57396;stroke-dasharray:none;stroke-opacity:1" id="rect5" width="25.801872" height="5.860003" x="119.94384" y="98.674728" ry="0"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:6.03661;stroke-dasharray:none;stroke-opacity:1" id="rect6" width="6" height="30.334635" x="130.05539" y="101.46412"></rect>
          </g>
          <path style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.81338;stroke-dasharray:none;stroke-opacity:1" d="m 100.03961,131.46649 h 6 v 33.97218 h -6 z" id="path4"></path>
          <g id="g9" transform="matrix(1,0,0,1.0199169,-0.14807164,31.087934)">
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.43999;stroke-dasharray:none;stroke-opacity:1" id="rect8" width="6" height="33.229393" x="64.364632" y="98.429321"></rect>
            <rect style="opacity:1;fill:#ffffff;fill-opacity:1;stroke:none;stroke-width:5.84555;stroke-dasharray:none;stroke-opacity:1" id="rect9" width="21.184687" height="5.8828321" x="64.373192" y="125.75582"></rect>
          </g>
        </g>
      </svg>
    </a>
    <a href="https://www.litfarms.com" class="header-link" style="margin: 0px 0; margin-left: -10px; margin-top:5px;">
      <h1 >Farms Products</h1>
    </a>
	<hr>
	   <div id="product-count" style="margin: 0px 0;margin-left: auto;margin-right: 20px;">
      Showing 0 products
    </div>
	<div id="countdown-label" style="text-align:center;margin: 0px 0;margin-left: auto;margin-right: auto;"><strong class="countdown-time">5:00</strong> Stock Refresh Timer</div>
  
  </div>
    <div class="filters">
      <div class="search-container">
        <input type="text" id="product-search-filter" class="search-input" placeholder="Search products...">
        <button id="clear-search" class="clear-search">&times;</button>
      </div>
      <select id="strain-filter">
        <option value="all">All Tiers</option>
        <option value="Essential">Essential</option>
        <option value="Preferred">Preferred</option>
        <option value="Supreme">Supreme</option>
      </select>
      <select id="strain-type-filter">
        <option value="all">All Types</option>
        <option value="sativa">Sativa</option>
        <option value="indica">Indica</option>
        <option value="hybrid">Hybrid</option>
        <option value="unknown">Unknown</option>
      </select>
      <!---<select id="weight-filter">
        <option value="all">All Weights</option>
        <option value="28g">28g</option>
        <option value="28g (Smalls)">28g (Smalls)</option>
        <option value="3.5g">3.5g</option>
      </select>--->
	  <div id="weight-filter-container" class="filter-group filter-dropdown-container">
    <button id="weight-dropdown-toggle" class="dropdown-toggle" aria-expanded="false">
        Weight
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="toggle-icon"><polyline points="6 9 12 15 18 9"></polyline></svg>
    </button>
</div>
      <select id="sort-filter">
        <option value="alpha-asc">A-Z</option>
        <option value="alpha-desc">Z-A</option>
        <option value="price-asc">Price: Low to High</option>
        <option value="price-desc">Price: High to Low</option>
        <option value="date-desc">Newest First</option>
        <option value="date-asc">Oldest First</option>
      </select>
      <button id="stock-filter" class="stock-filter-btn active">Show All</button>
    </div>
 <!--<div class="countdown-container" style=" ">
    <div class="countdown-circle" style="margin: 0 auto;">
	
      <div class="countdown-time">5:00</div>
    </div>
  </div>-->
     </div>
  </div>
  
  
  <div class="product-grid" id="product-grid">
    <!-- Product cards will be dynamically inserted here -->
  </div>

  <div id="loader" class="loader-container" style="display: none; ">
    <span class="loader"></span>
    <div class="loader-text">Loading products...</div>
  </div>

  <script>
    // Define the URL for the products.json endpoint
    const shopifyStoreUrl = 'https://litfarms.com/products.json';
    
    // Ntfy configuration
    const NTFY_CONFIG = {
      appEnabled: false, // App notifications enabled
      emailEnabled: false, // Email notifications enabled
      topic: '', // Will be set in settings
      server: 'https://ntfy.sh', // Default server, can be changed in settings
      email: '' // Email for notifications
    };

    // Declare updateCheckerId at the top level
    let updateCheckerId = null;

    // Settings Management
    const DEFAULT_SETTINGS = {
      checkInterval: 5, // minutes
      notificationTiers: ['all'],
      notificationWeights: ['all'],
      notifyNew: true,
      inBrowserNotificationsEnabled: true,
      notifyStock: true,
      notifyRemoved: true,
      specificProducts: [], // Array of product handles
      ntfyAppEnabled: false,
      ntfyEmailEnabled: false,
      ntfyTopic: '',
      ntfyServer: 'https://ntfy.sh',
      ntfyEmail: ''
    };

    let currentSettings = { ...DEFAULT_SETTINGS };

    function loadSettings() {
      const savedSettings = localStorage.getItem('litFarmsNotificationSettings');
      if (savedSettings) {
        currentSettings = { ...DEFAULT_SETTINGS, ...JSON.parse(savedSettings) };
      }
      // Update Ntfy config
      NTFY_CONFIG.appEnabled = currentSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = currentSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = currentSettings.ntfyTopic;
      NTFY_CONFIG.server = currentSettings.ntfyServer;
      NTFY_CONFIG.email = currentSettings.ntfyEmail;
      return currentSettings;
    }

    // Update saveSettings function to properly handle timer reset
    function saveSettings(settings) {
      const oldInterval = currentSettings.checkInterval;
      const newInterval = settings.checkInterval;
      
      localStorage.setItem('litFarmsNotificationSettings', JSON.stringify(settings));
      currentSettings = settings;
      
      // Only restart timers if the interval changed
      if (oldInterval !== newInterval) {
        // Clear existing intervals
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
          updateCheckerId = null;
        }
        
        // Clear all existing cleanup handlers
        pageCleanupHandlers.forEach(handler => {
          try {
            handler();
          } catch (error) {
            console.warn('Cleanup handler error:', error);
          }
        });
        pageCleanupHandlers = [];
        
        // Start new product checker and countdown
        startProductUpdateChecker();
      }
    }

    // Strain data
    const MANUAL_STRAIN_DATA = {
  "zereal": {
    "description": "Zerealz is a slightly indica dominant hybrid strain (60% indica/40% sativa) created through crossing the powerful Zkittlez X Cereal Milk strains. Looking for an insanely delicious flavor and a super euphoric yet relaxing high? Zerealz is definitely made for you. This bud packs a sweet and creamy fruity berry flavor into each and every toke, sharpened slightly by a sour citrus exhale. The aroma is earthy and herbal at the onset before settling into a sweet and fruity effect as the nugs are broken apart and burned away.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172569453
  },
  "white linen": {
    "description": "White Linen is an indica dominant hybrid strain (70% indica/30% sativa) created through crossing the delicious Wedding Cake #13 X Melonade strains. Named for its gorgeous appearance and soft, soothing high, White Linen is the perfect choice for any lover of classic flavorful indicas. This bud has beautiful fat heart-shaped bright neon green nugs with minty green undertones, lots of thin yellow-orange hairs and a frosty thick coating of slightly golden-white crystal trichomes.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738172600552
  },
  "lit og": {
    "description": "LIT OG: Where Tahoe OG meets Runtz in a legendary clash of titans. This unforgettable strain packs a powerful punch, leaving you feeling euphoric and blissful. But LIT OG isn't just about brute force. Its flavor profile is a delightful surprise, exploding with gassy OG terps that linger on the palate. It's the perfect choice for experienced users seeking a potent and flavorful experience that lives up to its name.",
    "category": "sativa",
    "phenotype": "sativa",
    "lastUpdate": 1738172799107
  },
  "lemon cherry belts": {
    "description": "Delivers a vibrant blend of sweet lemon zest and ripe cherries, with a smooth, creamy finish.",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738179317058
  },
  "glitter bomb": {
    "description": "Glitter Bomb THCa Flower will enchant you with its dazzling trichomes and hypnotic purple buds! It is a 70/30 indica dominant hybrid type 1 hemp flower that was indoor grown with living soil. This genetic gem of a strain is from crossing Grape Gas with OG Kush Breath Blueberry Headband, and exhibits notes of sweet, gas, and berries! This strain will have you dimension hopping with euphoria, transcendental thinking, and powerful relaxation!",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179386321
  },
  "apple banana zoap": {
    "description": "Apple Banana Zoap from LIT Farms is a cannabis strain that combines the flavors of apples, bananas, and zoap. The strain''s unique flavor profile blends sweet, creamy notes of apples and bananas with earthy, floral undertones of zoap, creating a rich and aromatic experience. This combination makes Apple Banana highly appealing to cannabis users. This strain offers a balanced high, combining relaxation and a gentle cerebral stimulation, making it suitable for both recreational and medicinal use. The potent levels of THC in Apple Banana provide a strong and long-lasting effect, helping to relieve stress, anxiety, and chronic pain.",
    "category": "indica",
    "phenotype": "indica",
    "lastUpdate": 1738179467896
  },
  "bubblegum runtz": {
    "description": "Bubble Runtz, also known as Bubblegum Runtz and Bubble Gum Runtz,, is a hybrid weed strain made by crossing Runtz and Bubble Gum. ",
    "category": "hybrid",
    "phenotype": "hybrid",
    "lastUpdate": 1738172799107
  }
};

    // Simplify loadStrainData to just use the constant
    async function loadStrainData() {
      try {
        //console.log('Loading strain data...');
        strainData = MANUAL_STRAIN_DATA;
        //console.log('Loaded strain data:', strainData);
        return strainData;
      } catch (error) {
        console.error('Error in loadStrainData:', error);
        return {};
      }
    }

    // Update getStrainType to use the new strain data
    function getStrainType(description, productHandle, productTitle) {
      //console.log(`Getting strain type for ${productTitle}`);
      
      // Clean the title first since we need it for both checks
      const cleanTitle = productTitle
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      // First check if product description explicitly mentions strain type
      if (description) {
        const temp = document.createElement('div');
        temp.innerHTML = description;
        const plainText = temp.textContent.toLowerCase();
        
        if (plainText.includes('sativa')) return 'sativa';
        if (plainText.includes('indica')) return 'indica';
        if (plainText.includes('hybrid')) return 'hybrid';
      }

      // If no strain type in product description, use manual strain type
      let strainInfo = strainData[cleanTitle];
      
      // If not found, try removing trailing 's' if present
      if (!strainInfo && cleanTitle.endsWith('s')) {
        const singularForm = cleanTitle.slice(0, -1);
        strainInfo = strainData[singularForm];
      }

      // Return the manual strain type if available
      if (strainInfo?.category) {
        return strainInfo.category.toLowerCase();
      }
      
      //console.log('is an unknown');
      return 'unknown';
    }

    // Function to show/hide loader
    function toggleLoader(show) {
      if (show) {
        domElements.loader.style.display = 'flex';
        domElements.productGrid.style.display = 'none';
      } else {
        domElements.loader.style.display = 'none';
        domElements.productGrid.style.display = 'grid';
      }
    }

    // Define global products variable
    let products = [];

    // Cache constants
    const CACHE_KEY = 'litFarmsProducts';
    const CACHE_TIMESTAMP_KEY = 'litFarmsLastUpdate';
    const CACHE_DURATION = 1 * 60 * 1000; // 1 minutes in milliseconds

    // Function to handle caching and fetching products
    async function getProducts(immediate = false) {
      const now = Date.now();
      const lastUpdate = localStorage.getItem(CACHE_TIMESTAMP_KEY);
      const cachedData = localStorage.getItem(CACHE_KEY);

      try {
        // Check for valid cached data
        if (cachedData && lastUpdate) {
          const parsedCache = JSON.parse(cachedData);
          const isValidCache = Array.isArray(parsedCache) && 
                              parsedCache.length > 0 && 
                              parsedCache[0].hasOwnProperty('title');

          if (isValidCache) {
            // Clear any stored error state since we have valid cache
            localStorage.removeItem('lastFetchError');
            
            // If this is an immediate request, return cached data regardless of age
            if (immediate) {
              return parsedCache;
            }
            
            // For background updates, check if cache is fresh enough
            if (now - parseInt(lastUpdate) < CACHE_DURATION && immediate) {
              return filterTHCAProducts(parsedCache);
            }
          }
        }

		// If we get here and immediate is true, cancel
		if(immediate)
			return false;
        // If we get here, we need fresh data
        console.log('Fetching fresh product data');
        const freshProducts = await fetchAllProducts();
        
        if (!Array.isArray(freshProducts) || freshProducts.length === 0) {
          throw new Error('Invalid or empty product data received');
        }

        // Clear any stored error state on successful fetch
        localStorage.removeItem('lastFetchError');

        const thcaProducts = filterTHCAProducts(freshProducts);
		//thcaProducts = thcaProducts;
       // const otherProducts = filterOtherProducts(freshProducts);
        
        if (thcaProducts.length > 0) {
          localStorage.setItem(CACHE_KEY, JSON.stringify(thcaProducts));
          localStorage.setItem(CACHE_TIMESTAMP_KEY, now.toString());
        }
        
        return thcaProducts;
      } catch (error) {
        console.error('Error in getProducts:', error);
        
        // Store the error state for maintenance mode detection
        if (error.message && error.message.includes('401')) {
          localStorage.setItem('lastFetchError', error.message);
        }
        
        // If this is an immediate request and we have any cached data, use it
        if (immediate && cachedData) {
          try {
            const parsedCache = JSON.parse(cachedData);
            if (Array.isArray(parsedCache) && parsedCache.length > 0) {
              return filterTHCAProducts(parsedCache);
            }
          } catch (e) {
            console.error('Failed to parse cached data:', e);
          }
        }
        
        throw error;
      }
    }

    // Update the fetchAllProducts function to include logging
    async function fetchAllProducts() {
      let allProducts = [];
      
      try {
        // Fetch first page
        const response = await fetch(`${shopifyStoreUrl}?page=1&limit=250`);
        const data = await response.json();
        
        if (data.products && data.products.length > 0) {
          allProducts = data.products;
          console.log(`Found ${data.products.length} products on page 1`);
          
          // Only continue fetching if we got the maximum number of products (250)
          if (data.products.length >= 250) {
            let page = 2;
            let hasMore = true;
            
            while (hasMore) {
              try {
                const nextResponse = await fetch(`${shopifyStoreUrl}?page=${page}&limit=250`);
                const nextData = await nextResponse.json();
                
                if (nextData.products && nextData.products.length > 0) {
                  console.log(`Found ${nextData.products.length} products on page ${page}`);
                  allProducts = allProducts.concat(nextData.products);
                  page++;
                  
                  // If we got less than 250 products, we've reached the end
                  if (nextData.products.length < 250) {
                    hasMore = false;
                  }
                } else {
                  hasMore = false;
                }
              } catch (error) {
                console.error('Error fetching page', page, ':', error);
                hasMore = false;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error fetching first page:', error);
      }

      console.log('Total products fetched:', allProducts.length);
      return allProducts;
    }

    function renderProducts(filteredProducts) {
      const productGrid = domElements.productGrid;
      domElements.productCount.innerHTML = `<strong>${filteredProducts.length}</strong> Products Shown`;

      // First, mark existing cards for fade out
      const existingCards = productGrid.querySelectorAll('.product-card');
      existingCards.forEach(card => card.classList.add('fade-out'));

      // Wait for fade out animation
      //setTimeout(() => {
        // Clear the grid but maintain the few-items class if it should stay
        const shouldHaveFewItems = filteredProducts.length < 4;
        const hadFewItems = productGrid.classList.contains('few-items');
        
        // Only remove the few-items class if we're transitioning from few to many
        if (hadFewItems && !shouldHaveFewItems) {
          productGrid.classList.remove('few-items');
        }
        
        productGrid.innerHTML = '';

        if (!hadFewItems && shouldHaveFewItems) {
          productGrid.classList.add('few-items');
        }

        // Calculate initial load count
        const productWidth = 250;
        const gap = 10;
        const containerWidth = productGrid.offsetWidth;
        const productsPerRow = Math.floor(containerWidth / (productWidth + gap));
        const initialLoadCount = productsPerRow * 2;

        // Function to render a batch of products with staggered animation
        const renderBatch = (products, startIndex, endIndex) => {
          products.slice(startIndex, endIndex).forEach((product, index) => {
            const productCard = document.createElement('div');
            productCard.className = 'product-card';
            productCard.style.animationDelay = `${index * 75}ms`; // Stagger the animations
            
            // Get filtered variants based on current filters
            const processedVariants = utils.processVariants(product);
            let relevantVariants = processedVariants;
            
            if (domElements.strainFilter.value !== 'all') {
              relevantVariants = relevantVariants.filter(v => v.correctedTier === domElements.strainFilter.value);
            }
			
			//if (selectedWeights.length >= 2) {
			//  relevantVariants = relevantVariants.filter(v => v.correctedTier === domElements.strainFilter.value);
			//}
              
			relevantVariants = relevantVariants.filter(v => selectedWeights.includes(v.correctedWeight) );
			
            
            if (!domElements.stockFilter.classList.contains('active')) {
              relevantVariants = relevantVariants.filter(v => v.available);
            }

            productCard.addEventListener('click', (e) => {
              // Check if the click was on the COA button
              if (e.target.classList.contains('coa-button')) {
                return; // Do nothing, let the COA button handle the click
              }

              // Regular click behavior - go to product page
              let url = `https://litfarms.com/products/${product.handle}`;
              if (relevantVariants.length === 1) {
                url += `?variant=${relevantVariants[0].id}`;
              }
              window.open(url, '_blank');
            });

            // Strain type badge
            const strainType = getStrainType(product.body_html, product.handle, product.title);
            const strainTypeBadge = createStrainTypeBadge(strainType);
            productCard.appendChild(strainTypeBadge);
            productCard.style.position = 'relative';

            // Create and add product image
            const imageContainer = createProductImage(product, relevantVariants);
            productCard.appendChild(imageContainer);

            const productTitle = createProductTitle(product);
            productCard.appendChild(productTitle);

            const priceContainer = createPriceContainer(product, relevantVariants, domElements.strainFilter.value, domElements.stockFilter.classList.contains('active'));
            productCard.appendChild(priceContainer);

            const productDescription = createProductDescription(product);
            productCard.appendChild(productDescription);
			
			// 1. Find all relevant elements on the current product card
const productImage = productCard.querySelector('.product-image');

// ðŸ”‘ REVERTED: Select all in-stock weight rows
const weightRows = productCard.querySelectorAll('.weight-row.in-stock');

if (productImage) {
    // Retrieve the primary source (stored on the <img> element)
    const primarySrc = productImage.dataset.primarySrc; 

    weightRows.forEach(row => {
        // Retrieve the variant-specific image source (must be stored on the weight-row div)
        const variantImageSrc = row.dataset.variantImageSrc;

        // Only attach listeners if this row has a specific image to show
        if (variantImageSrc) {
            
            // --- MOUSE ENTER (HOVER OVER) ---
            row.addEventListener('mouseenter', () => {
                // Only swap if the image needs to change
                if (productImage.src !== variantImageSrc) {
                    // Smooth transition effect (using CSS transition: opacity 0.2s)
                    productImage.style.opacity = 0; 
                    setTimeout(() => {
                        productImage.src = variantImageSrc;
                        productImage.style.opacity = 1;
                    }, 150); 
                }
            });

            // --- MOUSE LEAVE (HOVER OUT) ---
            row.addEventListener('mouseleave', () => {
                // Swap back to the primary image
                if (primarySrc && productImage.src !== primarySrc) {
                    productImage.style.opacity = 0; 
                    setTimeout(() => {
                        productImage.src = primarySrc;
                        productImage.style.opacity = 1;
                    }, 150);
                }
            });
        }
    });
}
			
            productGrid.appendChild(productCard);
          });
		  
        };

        // Render first two rows immediately
        renderBatch(filteredProducts, 0, initialLoadCount);

        // Render the rest after a short delay
        if (filteredProducts.length > initialLoadCount) {
          //setTimeout(() => {
            renderBatch(filteredProducts, initialLoadCount, filteredProducts.length);
          //}, 50); // Wait for initial batch animations to complete
        }
      //}, 10); // Match this with the fade-out transition duration
    }

    // Helper functions for rendering
    function createStrainTypeBadge(strainType) {
      const badge = document.createElement('div');
      badge.className = 'strain-type-badge';
      
      // Set badge color based on strain type
      switch(strainType) {
        case 'sativa':
          badge.style.backgroundColor = 'var(--strain-sativa)';
          badge.style.color = '#fff';
          break;
        case 'indica':
          badge.style.backgroundColor = 'var(--strain-indica)';
          badge.style.color = '#fff';
          break;
        case 'hybrid':
          badge.style.backgroundColor = 'var(--strain-hybrid)';
          badge.style.color = '#fff';
          break;
        default:
          badge.style.backgroundColor = 'var(--strain-unknown)';
          badge.style.color = '#fff';
      }
      
      badge.textContent = strainType;
      return badge;
    }

    function createProductImage(product, relevantVariants) {
      const imageContainer = document.createElement('div');
      imageContainer.className = 'product-image-container';
      
      const imageWrapper = document.createElement('div');
      imageWrapper.className = 'image-wrapper';
      
      const image = document.createElement('img');
      image.className = 'product-image';
      image.alt = product.title;
      
      imageWrapper.appendChild(image);
      imageContainer.appendChild(imageWrapper);

      // Filter images based on variants
      let filteredImages = [];
      if (product.images && product.images.length > 0) {
        //if (relevantVariants.length === product.variants.length) {
          // Show all images if all variants are selected
		//  console.log('using the all image variant alg');
        //  filteredImages = [product.images[0]]; // Just use first image
        //} else {
          // Get set of relevant variant IDs
          const relevantVariantIds = new Set(relevantVariants.map(v => v.id));
          const relevantVariantAvailable = new Set(relevantVariants.map(v => v.available));
		  const availableImgLink = product.images.find(variant => 
            relevantVariantIds.has(variant.id)
          );
		 // filteredImages = [availableImgLink.featured_image];
          //console.info('avail:' + availableImgLink.featured_image.src);
          // Try to find first image that matches a variant
          const variantImage = product.images.find(img => 
            img.variant_ids && 
            img.variant_ids.some(id => relevantVariantIds.has(id)) &&
			relevantVariants.some(variant => {/*console.log('log: ' + variant.available);*/ return variant.available;} ) === true
          );
		  const cleanTitle = product.title
			.replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
			.replace(/\s*-?\s*Flower\s*$/i, '')
			.replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
			.replace(/-/g, '')
			.replace(' ', '\n')
			.trim();
		  if(variantImage && variantImage.src !== undefined)
				filteredImages = variantImage.src;
		  else
			filteredImages = `https://placehold.co/300x300/${window.getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').replace('#','')}/${window.getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').replace('#','')}?text=${encodeURIComponent(cleanTitle)}`;
		  //console.log(variantImage[0].src);
          // Use variant image if found, otherwise use first product image
          //filteredImages = [variantImage || product.images[0]];
		  
        //}
      }

      // Set the image source
	  const primaryImageSrc = filteredImages;
      image.src = primaryImageSrc;
	  image.dataset.primarySrc = primaryImageSrc;

      // Remove tabIndex and keyboard handlers since we're not navigating images
      imageContainer.removeAttribute('tabIndex');

      return imageContainer;
    }

    function createProductTitle(product) {
      const title = document.createElement('h2');
      title.className = 'product-title';
      title.textContent = product.title;
      return title;
    }


    function createProductDescription(product) {
		try {
      const description = document.createElement('p');
      description.className = 'product-description';
      
      if (product.body_html) {
        const temp = document.createElement('div');
        temp.innerHTML = product.body_html.replace(/\s*style\s*=\s*(["']).*?\1/g, '');
        // Find any link that contains the text "Click here for product COA"
        const links = temp.getElementsByTagName('a');
        for (const link of links) {
          if (link.textContent.toLowerCase().includes('click here for product coa') || link.textContent.toLowerCase().includes('click here to see product coa')) {
            link.className = 'coa-button';
            link.textContent = 'View COA';
            link.target = '_blank';
            
            // Get the original href
            const originalUrl = link.href;
            
            // Check if it's a PDF link (look for .pdf anywhere in the URL)
            if (originalUrl.toLowerCase().includes('.pdf')) {
              // Use Google Docs viewer for PDFs
              // Extract the base URL without query parameters
              const baseUrl = originalUrl.split('?')[0];
              link.href = `https://docs.google.com/viewer?url=${encodeURIComponent(baseUrl)}&embedded=true`;
            }
            
            // Add event listener to stop propagation
            link.addEventListener('click', (e) => {
              e.stopPropagation(); // Stop the event from bubbling up
            });
          }
        }
        
        const plainText = temp.textContent
          .replace(/click here for product coa/gi, '')
          .replace(/\s+/g, ' ')
          .trim();
          
        if (plainText.length > 10) {
          description.innerHTML = temp.innerHTML;
          return description;
        }
      }
      
      // Only fall back to manual strain description if no product description
      const cleanStrainName = product.title
        .replace(/\s*-?\s*THCA\s+Flower\s*$/i, '')
        .replace(/\s*-?\s*Flower\s*$/i, '')
        .replace(/\s*-?\s*\d+\.?\d*g\s*$/i, '')
        .replace(/-/g, '')
        .trim()
        .toLowerCase();

      const leaflyData = strainData[cleanStrainName];
      description.innerHTML = leaflyData?.description || 'No description available.';
      return description;
	  } catch (error) {
		 console.error('Error creating product description', ':', error);
	  }
    }

 let selectedWeights = Array.from(document.querySelectorAll('#weight-checkbox-list input[type="checkbox"]:checked'))
        .map(cb => cb.value)
        .filter(value => value !== 'all'); // Exclude 'all' if you added that option
    // Update filter function
    function filterProducts() {
		selectedWeights = Array.from(document.querySelectorAll('#weight-checkbox-list input[type="checkbox"]:checked'))
			.map(cb => cb.value); 
      const strainFilter = domElements.strainFilter.value;
      const strainTypeFilter = domElements.strainTypeFilter.value;
      //const weightFilter = domElements.weightFilter.value;
			//console.log('\nWeight Filter: ' + weightFilter);
	  
      const stockFilter = domElements.stockFilter.classList.contains('active');
      const searchQuery = domElements.searchInput.value.toLowerCase().trim();
      const sortFilter = domElements.sortFilter.value;
      const filteredProducts = products.filter((product) => {
        // Check search query first
		//console.log(searchQuery);
        if (searchQuery && !product.title.toLowerCase().includes(searchQuery)) {
          return false;
        }
			
        // Process variants with utility function
        const correctedVariants = utils.processVariants(product);

        // If no valid variants at all, filter out the product
        if (correctedVariants.length === 0) {
          return false;
        }
		let itemsfound = 0;
		 if (selectedWeights) {
          const validWeightVariants = correctedVariants.filter(v => 
             selectedWeights.includes(v.correctedWeight) && 
			 v.hasPrice
          );
          if (validWeightVariants.length === 0) {
            return false;
          }
        }
		
        // Check if any variant matches the strain filter
        if (strainFilter !== 'all') {
          const validStrainVariants = correctedVariants.filter(v => 
            v.correctedTier === strainFilter &&
            v.hasPrice
          );
          if (validStrainVariants.length === 0) {
            return false;
          }
        }

        // Check strain type
        if (strainTypeFilter !== 'all') {
          const productStrainType = getStrainType(product.body_html, product.handle, product.title);
          if (productStrainType !== strainTypeFilter) {
            return false;
          }
        }

        // Check stock status
        if (!stockFilter) {
          let stockCheckVariants = correctedVariants;
          //if (selectedWeights.length < 2) {
		 if (selectedWeights) {
          stockCheckVariants = stockCheckVariants.filter(v => 
             selectedWeights.includes(v.correctedWeight) && 
			 v.hasPrice
          );
        }
          //}
          if (strainFilter !== 'all') {
            stockCheckVariants = stockCheckVariants.filter(v => v.correctedTier === strainFilter);
          }
          
          const hasInStockVariant = stockCheckVariants.some(variant => variant.available);
          if (!hasInStockVariant) {
            return false;
          }
        }

        return true;
      });

      // Sort the filtered products
	  //alert(sortFilter);
      const sortedProducts = utils.sortProducts(filteredProducts, sortFilter, strainFilter);
      // Render the sorted products
      renderProducts(sortedProducts);
    }

    // Functions to handle filter state persistence
    function saveFilterState() {
		let tempcheckboxes = [];
		const checkboxes = document.querySelectorAll('input.weight-checkbox[type="checkbox"]');
		checkboxes.forEach(function(checkbox) {
			tempcheckboxes.push(checkbox.checked);
		});
		//console.info(tempcheckboxes);
      const filterState = {
        strainFilter: document.getElementById('strain-filter').value,
        strainTypeFilter: document.getElementById('strain-type-filter').value,
        //weightFilter: document.getElementById('weight-filter').value,
        weightCheckboxList: tempcheckboxes,
        weightCheckboxListSelectedOptions: document.getElementsByClassName('weight-checkbox').value,
        sortFilter: document.getElementById('sort-filter').value,
        stockFilter: document.getElementById('stock-filter').classList.contains('active')
      };
      localStorage.setItem('litFarmsFilterState', JSON.stringify(filterState));
    }

    // 4. Update the Toggle Button text... (Logic remains the same)
    function updateWeightToggleText() {
		const weightList = document.getElementById('weight-checkbox-list');
		const toggleButton = document.getElementById('weight-dropdown-toggle');
        const selectedCount = weightList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (selectedCount > 0) {
            toggleButton.firstChild.textContent = `Weight (${selectedCount})`;
        } else {
            toggleButton.firstChild.textContent = 'Weight';
        }
    }
    function loadFilterState() {
		
	  //Populate Weight Filter checkboxes
	  //populateWeightCheckboxes(WEIGHTS);
      const savedState = localStorage.getItem('litFarmsFilterState');
      if (savedState) {
        const filterState = JSON.parse(savedState);
        
        // Restore select filters and update their styles
        const selects = {
          'strain-filter': filterState.strainFilter,
          'strain-type-filter': filterState.strainTypeFilter,
          //'weight-filter': filterState.weightFilter,
          'sort-filter': filterState.sortFilter
        };

        Object.entries(selects).forEach(([id, value]) => {
          const select = document.getElementById(id);
          select.value = value;
          updateSelectStyle(select);
        });
		
        // Weight filter
		
		const checkboxes = document.querySelectorAll('input.weight-checkbox[type="checkbox"]');
		
		checkboxes.forEach(function(checkbox, index) {
			checkbox.checked = filterState.weightCheckboxList[index];
		});
			
        
        // Restore stock filter button state
        const stockButton = document.getElementById('stock-filter');
        if (filterState.stockFilter) {
          stockButton.classList.add('active');
          stockButton.textContent = 'Showing All Items';
        } else {
          stockButton.classList.remove('active');
          stockButton.textContent = 'In Stock Only';
        }
      } else {
		  
		  const checkboxes = document.querySelectorAll('input.weight-checkbox[type="checkbox"]');
		checkboxes.forEach(function(checkbox) {
			checkbox.checked = true;
		});
		 document.getElementById('sort-filter').value = "price-asc";
        // Set default state for first-time users: In Stock Only
        const stockButton = document.getElementById('stock-filter');
        stockButton.classList.remove('active');
        stockButton.textContent = 'In Stock Only';
		
      }

      // Always reset search input
      const searchInput = document.getElementById('product-search-filter');
      const clearSearchButton = document.getElementById('clear-search');
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
	  
		const dropdownContent = document.getElementById('weight-filter-dropdown');
		const applyButton = dropdownContent.querySelector('.apply-filters');
		//applyButton.click();
		updateWeightToggleText();
    }

    // Event listeners for filters
    document.getElementById('strain-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    document.getElementById('strain-type-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

   /* document.getElementById('weight-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });*/
	

    document.getElementById('sort-filter').addEventListener('change', (e) => {
      updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });

    // Function to update select element style based on selection
    function updateSelectStyle(selectElement) {
      // Don't apply styles to the sort filter since it has no default option
      if (selectElement.id === 'sort-filter') {
        return;
      }
      
      if (selectElement.value === 'all') {
        selectElement.classList.remove('has-selection');
      } else {
        selectElement.classList.add('has-selection');
      }
    }

    document.getElementById('stock-filter').addEventListener('click', () => {
      const button = document.getElementById('stock-filter');
      button.classList.toggle('active');
      button.textContent = button.classList.contains('active') ? 'Showing All Items' : 'In Stock Only';
      filterProducts();
      saveFilterState();
    });

    
    // Function to compare products and detect changes
    function detectProductChanges(oldProducts, newProducts) {
      log(LOG_LEVELS.INFO, '=== Starting Product Change Detection ===');
      log(LOG_LEVELS.INFO, `Old products count: ${oldProducts.length}`);
      log(LOG_LEVELS.INFO, `New products count: ${newProducts.length}`);

      // Check for maintenance mode
      if (newProducts.length === 0 && oldProducts.length > 0) {
        // This might be maintenance mode rather than actual product removal
        // We'll check the last error in the fetch
        const lastError = localStorage.getItem('lastFetchError');
        if (lastError && lastError.includes('401')) {
          log(LOG_LEVELS.WARN, 'Site appears to be in maintenance mode, skipping change detection');
          return {
            new: [],
            stockChanged: [],
            removed: [],
            maintenanceMode: true
          };
        }
      }

      // Helper function to check if a product matches current filters
      function matchesFilters(product) {
        const variants = utils.processVariants(product);
        
        // If specific products are selected, only check those
        if (currentSettings.specificProducts.length > 0) {
          return currentSettings.specificProducts.includes(product.handle);
        }

        // Check if any variant matches the tier and weight filters
        return variants.some(variant => {
          const matchesTier = currentSettings.notificationTiers.includes(variant.correctedTier);
          const matchesWeight = currentSettings.notificationWeights.includes(variant.correctedWeight);
          return matchesTier && matchesWeight;
        });
      }

      const changes = {
        new: [],
        stockChanged: [],
        removed: []
      };

      // Check for new products
      if (currentSettings.notifyNew) {
        const oldHandles = new Set(oldProducts.map(p => p.handle));
        const newlyAdded = newProducts.filter(p => !oldHandles.has(p.handle));
        
        newlyAdded.forEach((newProduct, index) => {
          if (matchesFilters(newProduct)) {
            log(LOG_LEVELS.INFO, `New product detected: ${newProduct.title}`);
            changes.new.push(newProduct);
			let tempNewTiers = [];
			let tempNewWeights = [];
			newProduct.variants.forEach(v => {
				
				let weight = null;
				if (utils.isWeight(v.option1)) {
					weight = v.option1;
				} else if (utils.isWeight(v.option2)) {
					weight = v.option2;
				} else if (!WEIGHTS.includes(v.option2)) {
					weight = "Other";
				}
				tempNewWeights.push(weight);
				let tier = null;
				if (utils.isTier(v.option1)) {
					tier = v.option1;
				} else if (utils.isTier(v.option2)) {
					tier = v.option2;
				} else if (!TIERS.includes(v.option2)) {
					tier = "Other";
				}
				tempNewTiers.push(tier);
			});
			//window.showNotification(`Name: ${newProduct.title}<br>Tiers: ${$tempNewTiers.split(', ')}<br>Weights: ${$tempNewTiers.split(', ')}`, 500000, "New Product Available");
                 
          }
        });
      }

      // Check for stock changes and variant changes
      if (currentSettings.notifyStock) {
        newProducts.forEach(newProduct => {
          const oldProduct = oldProducts.find(p => p.handle === newProduct.handle);
          if (oldProduct && matchesFilters(newProduct)) {
            const oldVariants = utils.processVariants(oldProduct);
            const newVariants = utils.processVariants(newProduct);

            let hasChanges = false;
            const changedVariants = [];

            // Check for changes in existing variants
            newVariants.forEach(newVariant => {
				const oldVariant = oldVariants.find(v => {
					// 1. Check for a match
					const isMatch = v.id === newVariant.id;

					// 2. Perform the side-effect (show notification) ONLY if it's the match
					if (!isMatch) {
						// Warning: This runs the notification inside the search loop
						//window.showNotification(v.title, 500000, " match");
					}

					// 3. MUST explicitly return true or false for the search to work
					return isMatch;
				});
              if (oldVariant) {
                if (oldVariant.available !== newVariant.available || oldVariant.price !== newVariant.price) {
                  hasChanges = true;
                  changedVariants.push({
                    ...newVariant,
                    oldPrice: oldVariant.price,
                    oldAvailable: oldVariant.available
                  });
                  log(LOG_LEVELS.INFO, `Variant change detected for ${newProduct.title}`, {
                    tier: newVariant.correctedTier,
                    weight: newVariant.correctedWeight,
                    oldPrice: oldVariant.price,
                    newPrice: newVariant.price,
                    oldAvailable: oldVariant.available,
                    newAvailable: newVariant.available
                  });
				  /*
				  if(oldVariant.price != newVariant.price && oldVariant.available != newVariant.available)
				      window.showNotification(`Name: ${newProduct.title}<br>Tier: ${newVariant.correctedTier}<br>Price: From ${oldVariant.price} to ${newVariant.price}<br>Available: Was ${oldVariant.available}, is now ${newVariant.available}`, 500000, "Product Changed");
                  else if(oldVariant.price != newVariant.price)
					  window.showNotification(`Name: ${newProduct.title}<br>Tier: ${newVariant.correctedTier}<br>Price: From ${oldVariant.price} to ${newVariant.price}`, 500000, "Product Changed");
                  else 
					  window.showNotification(`Name: ${newProduct.title}<br>Tier: ${newVariant.correctedTier}<br>Weight: ${newVariant.correctedWeight}<br> Available: Was ${oldVariant.available}, is now ${newVariant.available}`, 500000, "Product Changed");
				 */
				}
              } else {
                // New variant added
                hasChanges = true;
                changedVariants.push(newVariant);
                log(LOG_LEVELS.INFO, `New variant added to ${newProduct.title}`, {
                  tier: newVariant.correctedTier,
                  weight: newVariant.correctedWeight,
                  price: newVariant.price,
                  available: newVariant.available
                });
				//window.showNotification(`Name: ${newProduct.title}<br>Tier: ${newVariant.correctedTier}<br>Price: ${newVariant.price}<br>Weight: ${newVariant.correctedWeight}`, 500000, "New Tier Available");
                  
              }
            });

            if (hasChanges) {
              changes.stockChanged.push({
                ...newProduct,
                changedVariants
              });
            }
          }
        });
      }

      // Check for removed products
      if (currentSettings.notifyRemoved) {
        const newHandles = new Set(newProducts.map(p => p.handle));
        oldProducts.forEach(oldProduct => {
          if (!newHandles.has(oldProduct.handle) && matchesFilters(oldProduct)) {
            log(LOG_LEVELS.INFO, `Product removed: ${oldProduct.title}`);
            changes.removed.push(oldProduct);
          }
        });
      }

      // Log summary of changes
      log(LOG_LEVELS.INFO, '=== Change Detection Summary ===', {
        newProducts: changes.new.length,
        stockChanges: changes.stockChanged.length,
        removedProducts: changes.removed.length
      });

      return changes;
    }

    // Function to send Ntfy notification
    async function sendNtfyNotification(title, message, priority = 3) {
      if (!NTFY_CONFIG.appEnabled && !NTFY_CONFIG.emailEnabled) {
        console.log('No notification methods enabled');
        return;
      }

      if (NTFY_CONFIG.appEnabled && !NTFY_CONFIG.topic) {
        console.log('App notifications enabled but no topic set');
        return;
      }

      if (NTFY_CONFIG.emailEnabled && !NTFY_CONFIG.email) {
        console.log('Email notifications enabled but no email set');
        return;
      }

      try {
        const headers = {
          'X-Title': title,
          'X-Priority': priority.toString(),
          'X-Tags': 'cannabis,stock'
        };

        // Email header
        if (NTFY_CONFIG.emailEnabled && NTFY_CONFIG.email) {
          headers['X-Email'] = NTFY_CONFIG.email;
        }

        // Send notification - we need a topic even for email-only notifications
        const topic = NTFY_CONFIG.appEnabled ? NTFY_CONFIG.topic : 'email-only-' + Math.random().toString(36).substring(7);
        
        const response = await fetch(`${NTFY_CONFIG.server}/${topic}`, {
          method: 'POST',
          headers: headers,
          body: message
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        console.log('Notification sent successfully');
      } catch (error) {
        console.error('Failed to send notification:', error);
      }
    }

    // Function to check if a variant matches notification settings
    function matchesNotificationFilters(variant) {
      const matchesTier = currentSettings.notificationTiers.includes(variant.correctedTier);
      const matchesWeight = currentSettings.notificationWeights.includes(variant.correctedWeight);
      return matchesTier && matchesWeight;
    }

    // Update handleNotifications function to filter based on settings
    async function handleNotifications(changes) {
      if (changes.maintenanceMode) {
        // Only send maintenance mode notification if notifications are enabled
        if (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled) {
          const message = `ðŸ”§ MAINTENANCE MODE ðŸ”§

LitFarms website is currently in maintenance mode.
The product list will be updated once the site is back online.

Using cached data from: ${new Date(parseInt(localStorage.getItem(CACHE_TIMESTAMP_KEY))).toLocaleString()}

ðŸ•’ Status checked: ${new Date().toLocaleString()}`;

          await sendNtfyNotification('LitFarms Maintenance Mode', message, 3);
        }
        return;
      }

      if (!changes.new.length && !changes.stockChanged.length && !changes.removed.length) {
        return;
      }

      // Filter changes based on notification settings
      const filteredChanges = {
        new: changes.new.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        }),
        stockChanged: changes.stockChanged.filter(product => {
          // Only include products where changed variants match filters
          const filteredVariants = product.changedVariants.filter(variant => 
            matchesNotificationFilters(variant)
          );
          if (filteredVariants.length > 0) {
            // Update changedVariants to only include matching variants
            product.changedVariants = filteredVariants;
            return true;
          }
          return false;
        }),
        removed: changes.removed.filter(product => {
          const variants = utils.processVariants(product);
          return variants.some(variant => matchesNotificationFilters(variant));
        })
      };

      // Log all changes for record keeping
      log(LOG_LEVELS.INFO, '=== All Changes ===', changes);
      log(LOG_LEVELS.INFO, '=== Filtered Changes for Notifications ===', filteredChanges);

      // Only send notification if there are filtered changes and notifications are enabled
      if ((filteredChanges.new.length || filteredChanges.stockChanged.length || filteredChanges.removed.length) &&
          (NTFY_CONFIG.appEnabled || NTFY_CONFIG.emailEnabled || currentSettings.inBrowserNotificationsEnabled)) {
        
        let ntfyMessage = '';
        
        if (filteredChanges.new.length && currentSettings.notifyNew) {
          ntfyMessage += `ðŸŒŸ NEW PRODUCTS (${filteredChanges.new.length}) ðŸŒŸ\n\n`;
          filteredChanges.new.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += `ðŸŒ¿ ${p.title}\n`;
            matchingVariants.forEach(v => {
			  if(!v.available) return;
              ntfyMessage += `   â€¢ ${v.correctedTier} ${v.correctedWeight}\n`;
              ntfyMessage += `     ðŸ’° $${v.price} ${v.available ? '(In Stock)' : '(Out of Stock)'}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (filteredChanges.stockChanged.length && currentSettings.notifyStock) {
          ntfyMessage += `ðŸ“¦ STOCK CHANGES (${filteredChanges.stockChanged.length}) ðŸ“¦\n\n`;
          filteredChanges.stockChanged.forEach(p => {
            ntfyMessage += `ðŸŒ¿ ${p.title}\n\n`;
            
            // Get new variants (variants without oldPrice or oldAvailable)
            const newVariants = p.changedVariants.filter(v => !v.oldPrice && !v.oldAvailable);
            const nowInStock = p.changedVariants.filter(v => v.oldAvailable === false && v.available === true);
            const nowOutOfStock = p.changedVariants.filter(v => v.oldAvailable === true && v.available === false);
            const priceChanges = p.changedVariants.filter(v => v.oldPrice && v.price !== v.oldPrice);
            
            // New variants added
            if (newVariants.length > 0) {
              ntfyMessage += `   ðŸ†• NEW VARIANTS ADDED:\n`;
              newVariants.forEach(v => {
                ntfyMessage += `      â€¢ ${v.correctedTier} ${v.correctedWeight}\n`;
                if (v.available) {
                  ntfyMessage += `        ðŸ’° $${v.price} (In Stock)\n`;
                } else {
                  ntfyMessage += `        ðŸ’° $${v.price} (Out of Stock)\n`;
                }
              });
              ntfyMessage += '\n';
            }
            
            if (nowInStock.length > 0) {
              ntfyMessage += `   âœ… NOW IN STOCK:\n`;
              nowInStock.forEach(v => {
                ntfyMessage += `      â€¢ ${v.correctedTier} ${v.correctedWeight}\n        ðŸ’° $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }
            
            if (nowOutOfStock.length > 0) {
              ntfyMessage += `   âŒ NOW OUT OF STOCK:\n`;
              nowOutOfStock.forEach(v => {
                ntfyMessage += `      â€¢ ${v.correctedTier} ${v.correctedWeight}\n        ðŸ’° $${v.price}\n`;
              });
              ntfyMessage += '\n';
            }

            if (priceChanges.length > 0) {
              ntfyMessage += `   ðŸ’° PRICE CHANGES:\n`;
              priceChanges.forEach(v => {
                const priceChange = parseFloat(v.oldPrice) - parseFloat(v.price);
                const changeSymbol = priceChange > 0 ? 'â†“' : 'â†‘';
                ntfyMessage += `      â€¢ ${v.correctedTier} ${v.correctedWeight}\n`;
                ntfyMessage += `        Was: $${v.oldPrice} â†’ Now: $${v.price} ${changeSymbol}\n`;
                ntfyMessage += `        ${Math.abs(priceChange).toFixed(2)} ${priceChange > 0 ? 'decrease' : 'increase'}\n`;
              });
              ntfyMessage += '\n';
            }
          });
        }
        
        if (filteredChanges.removed.length && currentSettings.notifyRemoved) {
          ntfyMessage += `ðŸš« REMOVED PRODUCTS (${filteredChanges.removed.length}) ðŸš«\n\n`;
          filteredChanges.removed.forEach(p => {
            const matchingVariants = utils.processVariants(p).filter(v => matchesNotificationFilters(v));
            ntfyMessage += `âŒ ${p.title}\n`;
            matchingVariants.forEach(v => {
              ntfyMessage += `   â€¢ ${v.correctedTier} ${v.correctedWeight}\n`;
            });
            ntfyMessage += '\n';
          });
        }
        
        if (ntfyMessage) {
          ntfyMessage += `\nðŸ•’ Updated: ${new Date().toLocaleString()}`;
		  if(currentSettings.inBrowserNotificationsEnabled)
		  {
			  window.showNotification(ntfyMessage.replace(/\n/g,"<br>"), 500000, "Product Update");
		  }
		  else 
			await sendNtfyNotification('LitFarms Update', ntfyMessage);
        }
      }
    }
	async function checkForProductChanges() {
		const loaderText = document.querySelector('.loader-text');
		loaderText.innerText = "Comparing product databases...";
		const freshProducts = await getProducts(false); 
		const changes = detectProductChanges(products, freshProducts);

		if (changes.new.length > 0 || changes.stockChanged.length > 0 || changes.removed.length > 0) {
			console.log('Changes detected, updating state and sending notifications...');
			await handleNotifications(changes);
			//window.showNotification(`${changes.new.length} total changes, ${changes.stockChanged.length} stock changed, ${changes.removed.length} stock removed`, 60000, "Store Update!");
			getTiers();
			getWeights();
			products = freshProducts;
			lastProducts = freshProducts;
			updateProductSelectList();
			filterProducts();
		}
		else
		{
			window.showNotification(`No products have changed since the last check`, 60000, "Product Update Checker");
		}
		loaderText.innerText = "Loading...";
	}
    // Update the startProductUpdateChecker function
    function startProductUpdateChecker() {
      let lastProducts = products;
      const intervalMs = currentSettings.checkInterval * 60 * 1000;

      console.log(`Starting product update checker - checking every ${currentSettings.checkInterval} minutes`);
	  //window.showNotification(`Starting product update checker - checking every ${currentSettings.checkInterval} minutes`, 15000, "Product Update Checker");
      // Start the countdown timer and get cleanup function
      const countdownCleanup = startCountdownTimer(intervalMs);
      
      // Add countdown timer cleanup to pageCleanupHandlers
      pageCleanupHandlers.push(countdownCleanup);

      updateCheckerId = setInterval(async () => {
        try {
          checkForProductChanges();
        } catch (error) {
          console.error('Error checking for product updates:', error);
        }
      }, intervalMs);

      return updateCheckerId;
    }

    // Filter THCA products
    function filterTHCAProducts(products) {
      const thcaProducts = products.filter(product => 
        product.vendor === "Lost In Translation" &&
		product.title.includes("VIP Membership") === false //Membership causes error
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }
    /* Filter THCA products old
    function filterTHCAProducts(products) {
      const thcaProducts = products.filter(product => 
        product.title.toLowerCase().includes('thca') || 
        product.tags.includes('thca') || 
        product.product_type === 'THCA Flower'
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }*/
    // Filter Other products
    function filterOtherProducts(products) {
      const thcaProducts = products.filter(product => 
        !product.title.toLowerCase().includes('thca') || 
        !product.tags.includes('thca') || 
        !product.product_type === 'THCA Flower'
      );
      //console.log(`Filtered ${products.length} total products to ${thcaProducts.length} THCA products`);
      return thcaProducts;
    }

    // Update the preloadImages function to remove text updates
    function preloadImages(products) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => resolve();
          img.onerror = () => resolve();
          img.src = product.images[0].src;
        });
      }));
    }

    // Add cleanup handler for page unload
    let pageCleanupHandlers = [];
    
    window.addEventListener('beforeunload', () => {
      // Execute all cleanup handlers
      pageCleanupHandlers.forEach(handler => {
        try {
          handler();
        } catch (error) {
          console.warn('Cleanup handler error:', error);
        }
      });
    });

    // Add these utility functions for status management
    const statusManager = {
	  timeoutIds: [],
      show: (message, type = 'error') => {
        const statusBar = document.getElementById('site-status');
        const statusMessage = document.getElementById('status-message');
        const retryButton = document.getElementById('retry-button');
        
        statusBar.className = `site-status ${type}`;
        statusMessage.textContent = message;
        statusBar.style.display = 'block';
        
        // Show retry button for errors
        retryButton.style.display = type === 'error' ? 'inline-block' : 'none';
		const messageShowTime = 2500;
		if(statusManager.timeoutIds.length > 0)
		{
			
		}
		statusManager.timeoutIds.push(setTimeout(() => { statusManager.hide(messageShowTime); }, messageShowTime));
		if(statusManager.timeoutIds.length > 0)
			console.log('notification added to notification que. total: ' + statusManager.timeoutIds.length);
		//let timerId = setTimeout(() => {
		//	statusManager.hide(messageShowTime);
		//}, messageShowTime); // Schedules the function to run after 5 seconds
      },
      
      hide: (time) => {
			const statusBar = document.getElementById('site-status');
			statusBar.classList.toggle('hide');
      },
      
      update: (message) => {
        const statusMessage = document.getElementById('status-message');
        statusMessage.textContent = message;
      }
    };

    // Add maintenance mode check interval
    let maintenanceCheckerId = null;
    const MAINTENANCE_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes in milliseconds

    // Update attemptLoad function with periodic maintenance check
    async function attemptLoad() {
      let retryCount = 0;
      const maxRetries = 3;
      let imagePreloadAbortController = new AbortController();
      
      // Add cleanup handler
      pageCleanupHandlers.push(() => {
        imagePreloadAbortController.abort();
        if (updateCheckerId) {
          clearInterval(updateCheckerId);
        }
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
          maintenanceCheckerId = null;
        }
      });

      function startMaintenanceChecker() {
        if (maintenanceCheckerId) {
          clearInterval(maintenanceCheckerId);
        }

        // Update status message to show next check time
        const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
		window.showNotification(`LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`, 60000, "Error");

        maintenanceCheckerId = setInterval(async () => {
          try {
            console.log('Checking if site is back from maintenance...');
            const freshProducts = await getProducts(false);
            if (Array.isArray(freshProducts) && freshProducts.length > 0) {
              // Site is back! Clear maintenance checker and restart normal operation
              clearInterval(maintenanceCheckerId);
              maintenanceCheckerId = null;
              statusManager.hide();
              products = freshProducts;
              filterProducts();
              startProductUpdateChecker();
              console.log('Site is back online, resumed normal operation');
            }
          } catch (error) {
            console.log('Site still in maintenance mode');
            // Update status message with next check time
            const nextCheck = new Date(Date.now() + MAINTENANCE_CHECK_INTERVAL);
            window.showNotification(`LitFarms website is in maintenance mode. Next check at ${nextCheck.toLocaleTimeString()}. Using cached data.`, 60000, "Error");

          }
        }, MAINTENANCE_CHECK_INTERVAL);
      }

    // 4. Update the Toggle Button text... (Logic remains the same)
    function updateWeightToggleText() {
		const weightList = document.getElementById('weight-checkbox-list');
		const toggleButton = document.getElementById('weight-dropdown-toggle');
        const selectedCount = weightList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (selectedCount > 0) {
            toggleButton.firstChild.textContent = `Weight (${selectedCount})`;
        } else {
            toggleButton.firstChild.textContent = 'Weight';
        }
    }
	
	function countArrayChanges(currentArray, cachedJson, idKey = 'id') {

		// 1. Parse the cached JSON back into an array
		const cachedArray = JSON.parse(cachedJson);
		let totalChanges = 0;

		/**
		 * Helper to create a Map keyed by the unique identifier.
		 * @param {Array<Object>} arr The array to map.
		 * @returns {Map<string|number, Object>} Map of ID to the object.
		 */
		const buildIdMap = (arr) => {
			const map = new Map();
			for (const item of arr) {
				// Check for the mandatory ID key
				if (!item.hasOwnProperty(idKey)) {
					console.error(`Error: Object missing required ID key '${idKey}'. Property change tracking requires unique IDs.`);
					continue;
				}
				map.set(item[idKey], item);
			}
			return map;
		};

		/**
		 * Deeply compares two objects and counts the number of properties that are different,
		 * added, or removed. The ID key is ignored in the change count.
		 * @param {Object} oldObj The cached object (or empty object if addition).
		 * @param {Object} newObj The current object (or empty object if removal).
		 * @returns {number} The count of property differences.
		 */
		const countPropertyChanges = (oldObj, newObj) => {
			const oldKeys = Object.keys(oldObj);
			const newKeys = Object.keys(newObj);
			const allKeys = new Set([...oldKeys, ...newKeys]);
			let changes = 0;

			for (const key of allKeys) {
				// Skip the unique ID key itself
				if (key === idKey) continue; 

				const oldValue = oldObj[key];
				const newValue = newObj[key];
				
				// Check for property existence difference (added or removed property)
				if (oldValue === undefined || newValue === undefined) {
					// Property added (old undefined) or removed (new undefined)
					changes++;
				} 
				// Check for value difference (using stringify for deep check of nested data)
				else if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
					changes++;
				}
			}
			return changes;
		};

		// 2. Create ID-keyed maps for efficient lookup
		const currentMap = buildIdMap(currentArray);
		const cachedMap = buildIdMap(cachedArray);

		// 3. Collect all unique IDs present in either array
		const allIds = new Set([...currentMap.keys(), ...cachedMap.keys()]);

		// 4. Iterate over all IDs and count property changes
		for (const id of allIds) {
			const currentItem = currentMap.get(id);
			const cachedItem = cachedMap.get(id);

			if (currentItem && cachedItem) {
				// MODIFICATION: Item exists in both, count property differences
				totalChanges += countPropertyChanges(cachedItem, currentItem);

			} else if (currentItem) {
				// ADDITION: Item only in current, count all its properties as changes
				totalChanges += countPropertyChanges({}, currentItem);

			} else if (cachedItem) {
				// REMOVAL: Item only in cached, count all its properties as changes
				totalChanges += countPropertyChanges(cachedItem, {});
			}
		}

		return totalChanges;
	}
      async function tryLoad() {
        try {
          // Hide any existing status messages
          statusManager.hide();
          
          // Load notification settings first
          loadSettings();
          
          // First try to load cached products immediately
          products = await getProducts(true);
          if (Array.isArray(products) && products.length > 0) {
		   
            console.log(`Loaded ${products.length} cached THCA products`);
		    getTiers();
		    getWeights();
			loadFilterState();
            await loadStrainData();
            
            // Show products immediately
           // toggleLoader(false);
            
			//alert("Yeet");
            filterProducts();
            // Then check for updates in the background
            try {
				await checkForProductChanges();
            } catch (updateError) {
              console.warn('Background update failed:', updateError);
              if (updateError.message.includes('401')) {
                startMaintenanceChecker();
              }
            }
			
          } else {
            // No cached products, load fresh
            products = await getProducts(false);
            if (!Array.isArray(products) || products.length === 0) {
              throw new Error('No products loaded');
            }
		  getTiers();
		  getWeights();
            
            console.log(`Loaded ${products.length} fresh THCA products`);
			window.showNotification(`Loaded ${products.length} fresh products`, 60000, "Product Update Checker");
			
            loadFilterState();
            await loadStrainData();
            
            filterProducts();
          }

          // Start the update checker
           startProductUpdateChecker();
          toggleLoader(false);
          return true; // Success
        } catch (error) {
          console.error('Error in initialization:', error);
          
          if (error.message.includes('401')) {
            if (products && products.length > 0) {
              // We have cached data, start maintenance checker
              startMaintenanceChecker();
            } else {
				window.showNotification(`LitFarms website is currently in maintenance mode. Please try again later.`, 60000, "Error");
            }
          } else {
			  window.showNotification(`Unable to load products. Please try again later.`, 60000, "Error");
            statusManager.show('Unable to load products. Please try again later.', 'error');
          }
          
          if (retryCount < maxRetries) {
            retryCount++;
            statusManager.update(`Retrying... Attempt ${retryCount} of ${maxRetries}`);
            
            // Clear cache before retrying
            localStorage.removeItem(CACHE_KEY);
            localStorage.removeItem(CACHE_TIMESTAMP_KEY);
            
            // Wait a bit before retrying
            await new Promise(resolve => setTimeout(resolve, 2000));
            return tryLoad();
          }
          
          if (!products || products.length === 0) {
            const productGrid = document.getElementById('product-grid');
            productGrid.innerHTML = `
              <div style="
                text-align: center;
                padding: 20px;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 100%;
                max-width: 400px;
              ">
                <p style="
                  color: var(--status-error);
                  margin-bottom: 15px;
                  font-size: 16px;
                  line-height: 1.4;
                ">
                  Unable to load products. The LitFarms website may be in maintenance mode.
                </p>
                <button onclick="window.location.reload()" style="
                  background-color: var(--accent-primary);
                  color: var(--bg-primary);
                  border: none;
                  padding: 10px 20px;
                  border-radius: 5px;
                  cursor: pointer;
                  font-size: 14px;
                  transition: opacity 0.2s;
                ">
                  Refresh Page
                </button>
              </div>`;
            toggleLoader(false);
          }
          
          // Start maintenance checker if it was a 401 error
          if (error.message.includes('401')) {
            startMaintenanceChecker();
          }
          
          return false;
        }
      }

      // Initial load attempt
      return tryLoad();
    }

    // Add retry button handler
    document.getElementById('retry-button').addEventListener('click', async () => {
      toggleLoader(true);
      await attemptLoad();
    });

    // Update preloadImages function to accept abort signal
    function preloadImages(products, signal) {
      return Promise.all(products.map(product => {
        if (!product.images[0]?.src) return Promise.resolve();
        return new Promise((resolve, reject) => {
          const img = new Image();
          
          // Handle abort signal
          if (signal) {
            signal.addEventListener('abort', () => {
              img.src = '';
              resolve(); // Resolve instead of reject to avoid error logging
            });
          }
          
          img.onload = () => resolve();
          img.onerror = () => resolve(); // Resolve on error to continue loading
          img.src = product.images[0].src;
        });
      }));
    }

    // Document ready event listener
    document.addEventListener('DOMContentLoaded', async () => {
      toggleLoader(true);

      // Settings modal
      document.getElementById('settings-button').addEventListener('click', openSettingsModal);
      document.querySelector('.close-modal').addEventListener('click', closeSettingsModal);
      document.querySelector('.save-settings').addEventListener('click', saveSettingsFromForm);

      // Track mousedown position for modal
      let modalMouseDown = false;
      const modal = document.getElementById('settings-modal');
      
      modal.addEventListener('mousedown', (e) => {
        if (e.target === modal) {
          modalMouseDown = true;
        }
      });

      modal.addEventListener('mouseup', (e) => {
        if (e.target === modal && modalMouseDown) {
          closeSettingsModal();
        }
        modalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      modal.addEventListener('mouseleave', () => {
        modalMouseDown = false;
      });

      let retryCount = 0;
      const maxRetries = 3;

      await attemptLoad();
    });

    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }
function setSelectSizeToFitAll(selectElement) {
    if (!selectElement || selectElement.options.length === 0) return;

    const options = selectElement.options;
    const totalOptions = options.length;

    // --- 1. Measure the full vertical space of a single option ---
    const firstOption = options[0];
    const optionStyle = getComputedStyle(firstOption);

    // Get option's height (content + padding + border)
    const optionHeight = firstOption.offsetHeight; 
    
    // Explicitly measure the margins (your CSS sets this to 2px top/bottom)
    const marginTop = parseFloat(optionStyle.marginTop) || 0;
    const marginBottom = parseFloat(optionStyle.marginBottom) || 0;
    
    // Total vertical space one option takes up, including margin above/below
    const singleRowSpace = optionHeight + marginTop + marginBottom; 

    // --- 2. Calculate the total content height (sum of all option rows) ---
    // This is the ideal height if the container had zero padding/border
    const contentHeight = singleRowSpace * totalOptions; 

    // --- 3. Calculate the Container Offset (The space *around* the options) ---
    
    // a. Get the space above the first option: 
    // This is the select box's top padding and border.
    // We must temporarily set size to 1 to ensure the option is rendered and measurable.
    selectElement.size = 1; 
    const offsetTop = firstOption.offsetTop; // Space from select top edge to option top edge

    // b. Get the space below the last option:
    // This is the remaining height of the select container after content ends.
    // The total height with size=totalOptions includes the last option's bottom margin.
    selectElement.size = totalOptions;
    const selectTotalHeight = selectElement.offsetHeight;
    
    // The vertical position where the *content* ends (top edge of first option + total content height)
    const contentEndPosition = offsetTop + contentHeight;
    
    // The space at the bottom is the total container height minus the content end position
    // We use Math.max(0, ...) to ensure we don't get a negative value due to rounding errors.
    const offsetBottom = Math.max(0, selectTotalHeight - contentEndPosition);
    
    // Total offset is the space above and the space below
    const totalContainerOffset = offsetTop + offsetBottom;
    
    // --- 4. Final Calculation and Application ---
    
    // The total height is the sum of the perfect content height and the total offset.
    let idealHeight = contentHeight + totalContainerOffset;
    
    // Apply the exact pixel height to the element
    selectElement.style.height = (idealHeight + 1) + 'px'; // +1px safety buffer
    
    // Keep the size attribute set to the total options for compatibility
    selectElement.size = totalOptions;
}
	  function areAllOptionsSelected(selectElement) {

		  // If the select element doesn't allow multiple selections,
		  // this function will only return true if the *only* option is selected.
		  // For single-selects, checking if *any* option is selected is more common.
		  if (!selectElement.multiple) {
			return selectElement.selectedIndex !== -1; 
		  }

		  const allOptions = selectElement.options;
		  const selectedOptions = selectElement.selectedOptions;

		  return allOptions.length === selectedOptions.length;
		}
    // Settings Modal Management
    function openSettingsModal() {
      const modal = document.getElementById('settings-modal');
      modal.style.display = 'flex';
	  modal.classList.remove("closed");
	  modal.classList.add("open");
      
      // Load current settings into form
      document.getElementById('check-interval').value = currentSettings.checkInterval;
      document.getElementById('ntfy-enabled').checked = currentSettings.ntfyAppEnabled;
      document.getElementById('email-enabled').checked = currentSettings.ntfyEmailEnabled;
      document.getElementById('browser-noti-enabled').checked = currentSettings.inBrowserNotificationsEnabled;
      document.getElementById('ntfy-topic').value = currentSettings.ntfyTopic;
      document.getElementById('ntfy-server').value = currentSettings.ntfyServer;
      document.getElementById('ntfy-email').value = currentSettings.ntfyEmail;
      
      // Update the minutes suffix position immediately after setting the value
      requestAnimationFrame(updateMinutesSuffixPosition);
      
      // Set multiple select values
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');


	  //Populate the 
	  
	  tierSelect.innerHTML = '';
	  TIERS.forEach(tier => {
		// Output: [ 'Gold For Less', 'Berry Blast', 'Sativa Sour Diesel', 'Chocolate Bar' ]
		const newOptionHTML = `<option value="${tier}">${tier}</option>`;
		// 3. Append the new option HTML to the innerHTML of the select element
		tierSelect.innerHTML += newOptionHTML;
	  });
	  tierSelect.setAttribute('size', TIERS.length);
	  weightSelect.innerHTML = '';
	  WEIGHTS.forEach(tier => {
		// Output: [ 'Gold For Less', 'Berry Blast', 'Sativa Sour Diesel', 'Chocolate Bar' ]
		const newOptionHTML = `<option value="${tier}">${tier}</option>`;
		// 3. Append the new option HTML to the innerHTML of the select element
		weightSelect.innerHTML += newOptionHTML;
	  });
	  weightSelect.setAttribute('size', WEIGHTS.length);
	  setSelectSizeToFitAll(weightSelect);
	  setSelectSizeToFitAll(tierSelect);
      // Clear previous selections
      Array.from(tierSelect.options).forEach(option => option.selected = false);
      Array.from(weightSelect.options).forEach(option => option.selected = false);
      
      // Set new selections
      currentSettings.notificationTiers.forEach(tier => {
        const option = Array.from(tierSelect.options).find(opt => opt.value === tier);
        if (option) option.selected = true;
      });
      
      currentSettings.notificationWeights.forEach(weight => {
        const option = Array.from(weightSelect.options).find(opt => opt.value === weight);
        if (option) option.selected = true;
      });
      
      // If nothing is selected, select 'all' by default
      if (!Array.from(tierSelect.selectedOptions).length) {
		  for (let i = 0; i < tierSelect.options.length; i++) {
			  tierSelect.options[i].selected = true;
			}
        //tierSelect.querySelector('option[value="all"]').selected = true;
      }
      if (!Array.from(weightSelect.selectedOptions).length) {
		  	for (let i = 0; i < weightSelect.options.length; i++) {
			  weightSelect.options[i].selected = true;
			}
		//weightSelect.querySelector('option[value="all"]').selected = true;
      }
      
      // Set checkboxes
      document.getElementById('notify-new').checked = currentSettings.notifyNew;
      document.getElementById('notify-stock').checked = currentSettings.notifyStock;
      document.getElementById('notify-removed').checked = currentSettings.notifyRemoved;
      
      // Update product list and clear search
      updateProductSelectList();

      document.body.classList.add('modal-open');
    }

    function closeSettingsModal() {
		
	  document.getElementById('settings-modal').classList.add("closed");
	  document.getElementById('settings-modal').classList.remove("open");
      //document.getElementById('settings-modal').style.display = 'none';
      document.body.classList.remove('modal-open');
    }

    function getSelectedValues(selectElement) {
      const selectedValues = Array.from(selectElement.selectedOptions).map(option => option.value);
      // If nothing is selected or only 'all' is selected, return ['all']
      return selectedValues.length === 0 ? ['all'] : selectedValues;
    }

    function saveSettingsFromForm() {
      const newSettings = {
        checkInterval: parseInt(document.getElementById('check-interval').value) || DEFAULT_SETTINGS.checkInterval,
        notificationTiers: getSelectedValues(document.getElementById('notification-tier')),
        notificationWeights: getSelectedValues(document.getElementById('notification-weight')),
        notifyNew: document.getElementById('notify-new').checked,
        notifyStock: document.getElementById('notify-stock').checked,
        notifyRemoved: document.getElementById('notify-removed').checked,
        specificProducts: Array.from(document.querySelectorAll('#product-select input:checked')).map(cb => cb.value),
        ntfyAppEnabled: document.getElementById('ntfy-enabled').checked,
        ntfyEmailEnabled: document.getElementById('email-enabled').checked,
        ntfyTopic: document.getElementById('ntfy-topic').value.trim(),
        ntfyServer: document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer,
        ntfyEmail: document.getElementById('ntfy-email').value.trim(),
        inBrowserNotificationsEnabled: document.getElementById('browser-noti-enabled').checked
      };

      // Update Ntfy config
      NTFY_CONFIG.appEnabled = newSettings.ntfyAppEnabled;
      NTFY_CONFIG.emailEnabled = newSettings.ntfyEmailEnabled;
      NTFY_CONFIG.topic = newSettings.ntfyTopic;
      NTFY_CONFIG.server = newSettings.ntfyServer;
      NTFY_CONFIG.email = newSettings.ntfyEmail;

      // Log the settings being saved
      console.log('Saving settings:', newSettings);
      let tempBrowserNotis = currentSettings.inBrowserNotificationsEnabled;
      saveSettings(newSettings);
	  if(!tempBrowserNotis && currentSettings.inBrowserNotificationsEnabled)
		   window.showNotification(`Product updates will appear here`, 15000, "Lost in Translation");
      closeSettingsModal();
    }

    // Event listeners for the multiple selects
    document.addEventListener('DOMContentLoaded', () => {
      const tierSelect = document.getElementById('notification-tier');
      const weightSelect = document.getElementById('notification-weight');
      function handleAllOption(selectElement) {
        selectElement.addEventListener('change', (e) => {
          //const allOption = selectElement.querySelector('option[value="all"]');
		  const allSelected = areAllOptionsSelected(selectElement);
          const otherOptions = Array.from(selectElement.options).filter(opt => opt.value !== 'all');
          
          if (allSelected) {
            // If 'all' is selected, deselect other options
            otherOptions.forEach(opt => opt.selected = false);
          } else if (Array.from(selectElement.selectedOptions).length === 0) {
            // If nothing is selected, select 'all'
			  for (let i = 0; i < selectElement.options.length; i++) {
				  selectElement.options[i].selected = true;
				}
            //allOption.selected = true;
          } else {
            // If other options are selected, deselect 'all'
			
            //allOption.selected = false;
          }
        });
      }

      handleAllOption(tierSelect);
      handleAllOption(weightSelect);
    });



    // Dynamic suffix positioning
    function updateMinutesSuffixPosition() {
      const input = document.getElementById('check-interval');
      const suffix = input.nextElementSibling;
      const valueLength = input.value.length;
      const basePosition = 28; // Base position for single digit
      const digitWidth = 8; // Approximate width per digit
      
      // Calculate new position based on number of digits
      const newPosition = basePosition + (valueLength - 1) * digitWidth;
      suffix.style.left = `${newPosition}px`;
    }

    // Event listeners for the check interval input
    document.addEventListener('DOMContentLoaded', () => {
      const checkIntervalInput = document.getElementById('check-interval');
      
      // Update position on any input change
      checkIntervalInput.addEventListener('input', updateMinutesSuffixPosition);
      
      // Initial position
      updateMinutesSuffixPosition();
    });

    // Test Ntfy notification
    let testButtonCooldown = false;
    const COOLDOWN_PERIOD = 30000; // 10 seconds in milliseconds

    async function testNtfyNotification() {
      if (testButtonCooldown) {
        return;
      }

      // Get current form values instead of using saved settings
      const appEnabled = document.getElementById('ntfy-enabled').checked;
      const emailEnabled = document.getElementById('email-enabled').checked;
      const topic = document.getElementById('ntfy-topic').value.trim();
      const server = document.getElementById('ntfy-server').value.trim() || DEFAULT_SETTINGS.ntfyServer;
      const email = document.getElementById('ntfy-email').value.trim();

      if (!appEnabled && !emailEnabled) {
        alert('Please enable at least one notification method');
        return;
      }

      if (appEnabled && !topic) {
        alert('Please set a topic for app notifications');
        return;
      }

      if (emailEnabled && !email) {
        alert('Please set an email address for email notifications');
        return;
      }

      const testButton = document.getElementById('test-ntfy');
      testButton.disabled = true;
      testButton.textContent = 'Sending...';

      // Set cooldown flag
      testButtonCooldown = true;

      try {
        // Create temporary config for test
        const tempConfig = {
          appEnabled: appEnabled,
          emailEnabled: emailEnabled,
          topic: topic,
          server: server,
          email: email
        };

        // Store current config
        const originalConfig = { ...NTFY_CONFIG };
        
        // Temporarily set config to form values
        Object.assign(NTFY_CONFIG, tempConfig);

        const testMessage = `ðŸŒŸ NEW PRODUCTS (2) ðŸŒŸ

ðŸŒ¿ Blue Dream THCA Flower
   â€¢ Essential 28g
     ðŸ’° $49.99

ðŸŒ¿ Purple Punch THCA Flower
   â€¢ Supreme 28g
     ðŸ’° $89.99


ðŸ“¦ STOCK CHANGES (2) ðŸ“¦

ðŸŒ¿ Gelato THCA Flower

   âœ… NOW IN STOCK:
      â€¢ Essential 28g
        ðŸ’° $49.99

   âŒ NOW OUT OF STOCK:
      â€¢ Preferred 28g
        ðŸ’° $69.99


ðŸŒ¿ Wedding Cake THCA Flower

   âœ… NOW IN STOCK:
      â€¢ Supreme 28g
        ðŸ’° $89.99


ðŸš« REMOVED PRODUCTS (1) ðŸš«

âŒ Northern Lights THCA Flower


ðŸ•’ Updated: ${new Date().toLocaleString()}`;

        await sendNtfyNotification(
          'LitFarms Test Notification',
          testMessage
        );
        testButton.textContent = 'Notification Sent!';

        // Restore original config
        Object.assign(NTFY_CONFIG, originalConfig);
      } catch (error) {
        console.error('Failed to send test notification:', error);
        testButton.textContent = 'Error!';
        
        // Restore original config in case of error
        Object.assign(NTFY_CONFIG, originalConfig);
      }

      // Start cooldown timer
      setTimeout(() => {
        testButtonCooldown = false;
        testButton.disabled = false;
        testButton.textContent = 'Test Notifications';
      }, COOLDOWN_PERIOD);

      // Countdown timer
      let remainingTime = COOLDOWN_PERIOD / 1000;
      const countdownInterval = setInterval(() => {
        remainingTime--;
        if (remainingTime > 0) {
          testButton.textContent = `Wait ${remainingTime}s`;
        } else {
          clearInterval(countdownInterval);
        }
      }, 1000);
    }

    // Update selected products count
    function updateSelectedProductsCount() {
      const selectedCount = document.querySelectorAll('#product-select input:checked').length;
      const countElement = document.getElementById('products-selected-count');
      countElement.textContent = `${selectedCount} product${selectedCount === 1 ? '' : 's'} selected`;
    }

    // Deselect all products
    function deselectAllProducts() {
      const checkboxes = document.querySelectorAll('#product-select input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = false;
      });
      updateSelectedProductsCount();
    }

    // Update the updateProductSelectList function to include count updates
    function updateProductSelectList() {
      const productSelect = document.getElementById('product-select');
      productSelect.innerHTML = '';

      // Sort products alphabetically by title
      const sortedProducts = [...products].sort((a, b) => 
        a.title.toLowerCase().localeCompare(b.title.toLowerCase())
      );

      sortedProducts.forEach(product => {
        const item = document.createElement('div');
        item.className = 'product-select-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `product-${product.handle}`;
        checkbox.value = product.handle;
        checkbox.checked = currentSettings.specificProducts.includes(product.handle);
        
        // Update count
        checkbox.addEventListener('change', updateSelectedProductsCount);
        
        const label = document.createElement('label');
        label.htmlFor = `product-${product.handle}`;
        label.textContent = product.title;
        
        item.appendChild(checkbox);
        item.appendChild(label);
        productSelect.appendChild(item);
      });

      // Update initial count
      updateSelectedProductsCount();

      // Search functionality
      const searchInput = document.getElementById('product-search');
      
      function filterProducts(searchTerm) {
        const items = productSelect.getElementsByClassName('product-select-item');
        const term = searchTerm.toLowerCase();
        
        Array.from(items).forEach(item => {
          const label = item.querySelector('label');
          const title = label.textContent.toLowerCase();
          
          if (title.includes(term)) {
            item.classList.remove('hidden');
          } else {
            item.classList.add('hidden');
          }
        });
      }

      // Search event listener

      // Clear search when modal is opened
      searchInput.value = '';
      filterProducts('');
    }

    // Topic name arrays
    const ADJECTIVES = ['swift', 'bright', 'cosmic', 'mystic', 'golden', 'silver', 'crystal', 'azure', 'crimson', 'emerald'];
    const NOUNS = ['phoenix', 'dragon', 'falcon', 'tiger', 'wolf', 'eagle', 'lion', 'hawk', 'panther', 'bear'];
    
    // Random topic name generator
    function generateRandomTopic() {
      // Get random elements from arrays
      const adjective = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
      const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
      
      // Generate random numbers (4 digits)
      const numbers = Math.floor(1000 + Math.random() * 9000);
      
      // Generate random letters (2 characters)
      const letters = String.fromCharCode(65 + Math.floor(Math.random() * 26)) + 
                     String.fromCharCode(65 + Math.floor(Math.random() * 26));
      
      // Combine everything with dashes
      const topic = `litfarms-${adjective}-${noun}-${numbers}${letters}`;
      
      // Set the value in the input field
      document.getElementById('ntfy-topic').value = topic;
    }

    // Clear search functionality
    const clearSearchButton = document.getElementById('clear-search');
    const searchInput = document.getElementById('product-search-filter');

    // Show/hide clear button based on search input content
    searchInput.addEventListener('input', () => {
      clearSearchButton.style.display = searchInput.value ? 'flex' : 'none';
      filterProducts();
      saveFilterState();
    });

    // Move cursor to end when input receives focus
    searchInput.addEventListener('focus', () => {
      const length = searchInput.value.length;
      searchInput.setSelectionRange(length, length);
    });

    // Close keyboard on enter key press
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        searchInput.blur(); // This will close the keyboard on mobile
      }
    });

    // Clear search when button is clicked
    clearSearchButton.addEventListener('click', () => {
      searchInput.value = '';
      clearSearchButton.style.display = 'none';
      filterProducts();
      saveFilterState();
    });

    // Utility Functions
    let WEIGHTS = ['28g', '28g (Smalls)', '3.5g'];
    let TIERS = [];

  function getTiers() {
	let newTiers = [];
	const strainFilterElement = document.getElementById('strain-filter');
	strainFilterElement.innerHTML = '';
	const allOptionHTML = `<option value="all">All Tiers</option>`;
	strainFilterElement.innerHTML += allOptionHTML;
	products.forEach(product => {
		const options = product.options;
		options.forEach(option => {
			const name = option.name; 
			const values = option.values;
			if(name!="Tier")
				return;
			values.forEach(value => {
				//console.log(value);
					const variantIsInStock = product.variants.some(v => v.option1 === value && v.available && option.name != "Style");
					//  variantIsInStock removes old/misspelled tiers, at the cost of some out of stock products' tier showing as 'Other'
					if (value != product.title && variantIsInStock && !newTiers.includes(value)) newTiers.push(value);
			});
		});
	});
	newTiers.sort();
	newTiers.push("Other");
	TIERS = newTiers;
	TIERS.forEach(tier => {
	
		// Output: [ 'Gold For Less', 'Berry Blast', 'Sativa Sour Diesel', 'Chocolate Bar' ]
		const newOptionHTML = `<option value="${tier}">${tier}</option>`;
		// 3. Append the new option HTML to the innerHTML of the select element
		strainFilterElement.innerHTML += newOptionHTML;
	});
	//console.log("Tiers:", newTiers);
  }
  function getWeights() {
	let newTiers = [];
	const strainFilterElement = document.getElementById('weight-checkbox-list');
	strainFilterElement.innerHTML = '';
	products.forEach(product => {
		const options = product.options;
		options.forEach(option => {
			const name = option.name;
			if(name.toLowerCase() == "weight") {
				const values = option.values;
				values.forEach(val => {
					if(!newTiers.includes(val)) {
						const variantIsInStock = product.variants.some(v => v.available === true && v.option2.toLowerCase().includes(val.toLowerCase()));
						if (variantIsInStock) newTiers.push(val);
						
					}
				});
			}
		});
	});
	newTiers.push("Other");
	WEIGHTS = newTiers;
	WEIGHTS.forEach(tier => {
	
		// Output: [ 'Gold For Less', 'Berry Blast', 'Sativa Sour Diesel', 'Chocolate Bar' ]
		const newOptionHTML = `<li><label>
			<input type="checkbox" value="${tier}" class="weight-checkbox"> 
			${tier}
        </label></li>`;
		// 3. Append the new option HTML to the innerHTML of the select element
		strainFilterElement.innerHTML += newOptionHTML;
	});
	//console.log("Weights:", newTiers);
  }
    const utils = {
      isWeight: (value) => value && WEIGHTS.includes(value),
      isTier: (value) => value && TIERS.includes(value),
      hasValidPrice: (variant) => variant.price && !isNaN(parseFloat(variant.price)) && parseFloat(variant.price) > 0,
      
      standardizeWeight: (weightStr) => {
        if (!weightStr) return null;
        weightStr = weightStr.trim();
        return weightStr;
      },
      
      processVariants: (product) => {
        return product.variants.map(v => {
			let weight = null;
			if (utils.isWeight(v.option1)) {
				weight = v.option1;
			} else if (utils.isWeight(v.option2)) {
				weight = v.option2;
			} else if (!WEIGHTS.includes(v.option2)) {
				weight = "Other";
			}
			let tier = null;
			if (utils.isTier(v.option1)) {
				tier = v.option1;
			} else if (utils.isTier(v.option2)) {
				tier = v.option2;
			} else if (!TIERS.includes(v.option2)) {
				tier = "Other";
			}
          //let tier = utils.isTier(v.option1) ? v.option1 : utils.isTier(v.option2) ? v.option2 : null;
		  //console.log(tier);
          if (weight && !tier) tier = v.title;
		  if (!weight && !tier) { tier = product.title; console.log("NO WEIGHT OR TIER"); };
          return {
            ...v,
            correctedWeight: weight,
            correctedTier: tier,
            available: v.available,
            hasPrice: utils.hasValidPrice(v)
          };
        }).filter(v => v.correctedWeight && v.hasPrice);
      },
      
      getVariantKey: (variant) => 
        `${variant.correctedTier}-${variant.correctedWeight}-${variant.price}-${variant.available}`,
        
      extractTierAndWeight: (str) => {
        const parts = str.split('/').map(s => s.trim());
        const weightPart = parts.find(p => utils.isWeight(utils.standardizeWeight(p)));
        const tierPart = parts.find(p => TIERS.includes(p));
		
        return { 
          weight: weightPart ? utils.standardizeWeight(weightPart) : null, 
          tier: tierPart 
        };
      },

      sortProducts: (products, sortFilter, strainFilter) => {
        return [...products].sort((a, b) => {
          switch (sortFilter) {
            case 'alpha-asc':
              return a.title.localeCompare(b.title);
            case 'alpha-desc':
              return b.title.localeCompare(a.title);
            case 'date-desc':
			  return new Date(b.created_at) - new Date(a.created_at);
            case 'date-asc':
              return new Date(a.created_at) - new Date(b.created_at);
            case 'price-asc':
            case 'price-desc': {
              // Get valid variants for both products
              const aVariants = utils.processVariants(a);
              const bVariants = utils.processVariants(b);

              // Filter variants based on current filters
              let relevantAVariants = aVariants;
              let relevantBVariants = bVariants;
			  
			  
              if (selectedWeights.length <= 2) { //if not all wieghts are selected
			    relevantAVariants = relevantAVariants.filter(v => selectedWeights.some(allowedWeight => allowedWeight === v.correctedWeight));
			    relevantBVariants = relevantBVariants.filter(v => selectedWeights.some(allowedWeight => allowedWeight === v.correctedWeight));

              }
			  
              if (strainFilter !== 'all') {
                relevantAVariants = relevantAVariants.filter(v => v.correctedTier === strainFilter);
                relevantBVariants = relevantBVariants.filter(v => v.correctedTier === strainFilter);
              }
              
              // If in "In Stock Only" mode, only consider available variants
              if (!domElements.stockFilter.classList.contains('active')) {
                relevantAVariants = relevantAVariants.filter(v => v.available);
                relevantBVariants = relevantBVariants.filter(v => v.available);
              }

              // If no relevant variants after filtering, push to end of sort
              if (relevantAVariants.length === 0) return 1;
              if (relevantBVariants.length === 0) return -1;

              // Get the min/max prices for comparison
              const aPrice = relevantAVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantAVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantAVariants.map(v => parseFloat(v.price)))) : 
                Infinity;
              const bPrice = relevantBVariants.length ? 
                (sortFilter === 'price-asc' ? 
                  Math.min(...relevantBVariants.map(v => parseFloat(v.price))) : 
                  Math.max(...relevantBVariants.map(v => parseFloat(v.price)))) : 
                Infinity;

              // If prices are equal, sort alphabetically
              if (aPrice === bPrice) {
                return a.title.localeCompare(b.title);
              }

              return sortFilter === 'price-asc' ? aPrice - bPrice : bPrice - aPrice;
            }
            default:
              return 0;
          }
        });
      }
    };

    // Cache frequently accessed DOM elements
    const domElements = {
      productGrid: document.getElementById('product-grid'),
      productCount: document.getElementById('product-count'),
      strainFilter: document.getElementById('strain-filter'),
      strainTypeFilter: document.getElementById('strain-type-filter'),
      //weightFilter: document.getElementById('weight-filter'),
      sortFilter: document.getElementById('sort-filter'),
      stockFilter: document.getElementById('stock-filter'),
      weightCheckboxList: document.getElementById('weight-checkbox-list'),
      weightCheckboxListSelectedOptions: document.getElementsByClassName('weight-checkbox'),
      searchInput: document.getElementById('product-search-filter'),
      clearSearch: document.getElementById('clear-search'),
      loader: document.getElementById('loader'),
      settingsModal: document.getElementById('settings-modal')
    };

    // Constants for logging
    const LOG_LEVELS = {
      INFO: 'INFO',
      WARN: 'WARN',
      ERROR: 'ERROR'
    };

    function log(level, message, data = null) {
      const logMessage = `${message}`;
      
      switch(level) {
        case LOG_LEVELS.ERROR:
          data ? console.error(logMessage, data) : console.error(logMessage);
          break;
        case LOG_LEVELS.WARN:
          data ? console.warn(logMessage, data) : console.warn(logMessage);
          break;
        default:
          data ? console.log(logMessage, data) : console.log(logMessage);
      }
    }

    // Update startCountdownTimer function for better state management
    function startCountdownTimer(intervalMs) {
      const countdownEl = document.querySelector('.countdown-time');
	  //const clockElement = document.querySelector('.countdown-circle');

      const circumference = 2 * Math.PI * 16; // r = 16
      
      // Reset all visual elements first
      countdownEl.textContent = '';
      
      let timeLeft = intervalMs;
      let timerId = null;
      let isActive = true; // Track if this timer instance is active
      
      function updateCountdown() {
        // Only update if this timer instance is still active
        if (!isActive) return;
        
        const minutes = Math.floor(timeLeft / 60000);
        const seconds = Math.floor((timeLeft % 60000) / 1000);
        const display = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        countdownEl.textContent = display;
        
        // Update progress circle
        const progress = (timeLeft / intervalMs) * 100;
        const offset = circumference - (progress / 100) * circumference;
		const angle = Math.floor((progress / 100) * 360);
		//console.log('Angle: ' + angle);
		//clockElement.style.setProperty('--clock-progress', offset + 'deg');
        
        timeLeft -= 1000;
        
        if (timeLeft < 0) {
          timeLeft = intervalMs;
        }
      }
      
      // Initial update
      updateCountdown();
      
      // Start the interval
      timerId = setInterval(updateCountdown, 1000);
      
      // Return cleanup function
      return () => {
        isActive = false; // Mark this timer instance as inactive
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        // Reset visual elements on cleanup
        countdownEl.textContent = '';
      };
    }

    // Virtual Cart State
    const virtualCart = {
      items: [],
      
      addItem(product, variant) {
        // Add visual feedback to the clicked button
        const clickedButton = document.activeElement;
        if (clickedButton && clickedButton.classList.contains('add-to-cart-button')) {
          clickedButton.classList.add('clicked');
          setTimeout(() => clickedButton.classList.remove('clicked'), 300);
        }

        const existingItemIndex = this.items.findIndex(item => item.variantId === variant.id);
        
        if (existingItemIndex !== -1) {
          // Update quantity of existing item
          this.items[existingItemIndex].quantity += 1;
        } else {
          // Add new item with quantity 1
          this.items.push({
            productId: product.id,
            productTitle: product.title,
            variantId: variant.id,
            variantTitle: `${variant.correctedTier} ${variant.correctedWeight}`,
            price: parseFloat(variant.price),
            available: variant.available,
            quantity: 1
          });
        }

        // Add visual feedback to the cart icon
        const cartButton = document.getElementById('virtual-cart-button');
        cartButton.classList.add('pulse');
        setTimeout(() => cartButton.classList.remove('pulse'), 500);

        this.updateUI();
        this.saveToLocalStorage();
      },

      updateQuantity(index, newQuantity) {
        if (newQuantity > 0) {
          this.items[index].quantity = newQuantity;
          this.updateUI();
          this.saveToLocalStorage();
        } else {
          this.removeItem(index);
        }
      },

      removeItem(index) {
        this.items.splice(index, 1);
        this.updateUI();
        this.saveToLocalStorage();
      },

      clearCart() {
        this.items = [];
        this.updateUI();
        this.saveToLocalStorage();
      },

      updateUI() {
        // Update cart count (sum of all quantities)
        const cartCount = document.querySelector('.cart-count');
        const totalItems = this.items.reduce((sum, item) => sum + item.quantity, 0);
        cartCount.textContent = totalItems;

        // Update cart modal contents
        const cartItems = document.getElementById('cart-items');
        const cartTotal = document.getElementById('cart-total');
        
        if (this.items.length === 0) {
          cartItems.innerHTML = '<div class="empty-cart-message">Your cart is empty</div>';
          cartTotal.textContent = '0.00';
          return;
        }

        cartItems.innerHTML = this.items.map((item, index) => `
          <div class="cart-item">
            <div class="cart-item-info">
              <div class="cart-item-title">${item.productTitle}</div>
              <div class="cart-item-variant">${item.variantTitle}</div>
              <div class="cart-item-price">$${(item.price * item.quantity).toFixed(2)}</div>
            </div>
            <div class="cart-item-controls">
              <div class="quantity-controls">
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity - 1})">-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-btn" onclick="virtualCart.updateQuantity(${index}, ${item.quantity + 1})">+</button>
              </div>
              <button class="remove-from-cart" onclick="virtualCart.removeItem(${index})">Ã—</button>
            </div>
          </div>
        `).join('');

        // Update total
        const total = this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
        cartTotal.textContent = total.toFixed(2);
      },

      saveToLocalStorage() {
        localStorage.setItem('virtualCart', JSON.stringify(this.items));
      },

      loadFromLocalStorage() {
        const saved = localStorage.getItem('virtualCart');
        if (saved) {
          this.items = JSON.parse(saved);
          this.updateUI();
        }
      }
    };

    // Cart Modal Functions
    function openCartModal() {
     // document.getElementById('cart-modal').style.display = 'flex';
      document.getElementById('cart-modal').classList.add('open');
      document.getElementById('cart-modal').classList.remove('closed');
    }

    function closeCartModal() {
     // document.getElementById('cart-modal').style.display = 'none';
      document.getElementById('cart-modal').classList.remove('open');
      document.getElementById('cart-modal').classList.add('closed');
    }

    function checkout() {
      if (virtualCart.items.length === 0) return;

      // Create a form to submit all items
      const form = document.createElement('form');
      form.method = 'post';
      form.action = 'https://litfarms.com/cart/add';
      form.target = '_blank';

      // Add each item as a hidden input with its quantity
      virtualCart.items.forEach((item, index) => {
        const input = document.createElement('input');
        input.type = 'hidden';
        input.name = `items[${index}][id]`;
        input.value = item.variantId;
        form.appendChild(input);

        const quantityInput = document.createElement('input');
        quantityInput.type = 'hidden';
        quantityInput.name = `items[${index}][quantity]`;
        quantityInput.value = item.quantity.toString();
        form.appendChild(quantityInput);
      });

      // Submit the form
      document.body.appendChild(form);
      form.submit();
      document.body.removeChild(form);

      // Clear the virtual cart
      virtualCart.clearCart();
      closeCartModal();
    }

    // Initialize cart
    document.addEventListener('DOMContentLoaded', () => {
      virtualCart.loadFromLocalStorage();
      
      // Add cart button click handler
      document.getElementById('virtual-cart-button').addEventListener('click', openCartModal);

      // Track mousedown position for cart modal
      let cartModalMouseDown = false;
      const cartModal = document.getElementById('cart-modal');
      
      cartModal.addEventListener('mousedown', (e) => {
        if (e.target === cartModal) {
          cartModalMouseDown = true;
        }
      });

      cartModal.addEventListener('mouseup', (e) => {
        if (e.target === cartModal && cartModalMouseDown) {
          closeCartModal();
        }
        cartModalMouseDown = false;
      });

      // Reset flag when mouse leaves modal
      cartModal.addEventListener('mouseleave', () => {
        cartModalMouseDown = false;
      });
    });

	
    // Update createPriceContainer to add "Add to Cart" buttons
    function createPriceContainer(product, variants, strainFilter, stockFilter) {
      const container = document.createElement('div');
      container.className = 'price-container';

      // Group variants by tier
      const variantsByTier = {};
      TIERS.forEach(tier => {
        variantsByTier[tier] = [];
      });

      variants.forEach(variant => {
        if (variant.correctedTier && variant.correctedWeight) {
          variantsByTier[variant.correctedTier].push(variant);
        }
      });

      // Create sections for each tier
      TIERS.forEach(tier => {
        if (strainFilter !== 'all' && tier !== strainFilter) {
          return;
        }

        const tierVariants = variantsByTier[tier];
        if (tierVariants && tierVariants.length > 0) {
          const filteredVariants = tierVariants.filter(variant => {
            if (selectedWeights.length < 2 && !selectedWeights.includes(variant.correctedWeight)) {
              return false;
            }
            if (!stockFilter && !variant.available) {
              return false;
            }
            return true;
          });
			//console.log('filteredVariants Length: ' + filteredVariants.length);
          if (filteredVariants.length > 0) {
            const section = document.createElement('div');
            section.className = `variant-section variant-section-${tier.toLowerCase()}`;
			
            const title = document.createElement('div');
            title.className = `variant-title variant-title-${tier.toLowerCase()}`;
            title.textContent = tier;
            section.appendChild(title);

            const weights = document.createElement('div');
            weights.className = 'variant-weights';

            filteredVariants.forEach(variant => {
              const row = document.createElement('div');
              row.className = variant.available ? 'weight-row in-stock' : 'weight-row out-of-stock';
              // 1. Find the image for this specific variant by variant ID
				const variantImageObject = product.images.find(img => 
					img.variant_ids && img.variant_ids.includes(variant.id)
				);
				
				// 2. Attach the source to the variant section if found and in stock
				if (variant.available && variantImageObject) {
					// ðŸ”‘ NEW: Store the variant's specific image URL on the variantSection div
					row.dataset.variantImageSrc = variantImageObject.src;
				}
              // Add click handler to stop event propagation
              row.addEventListener('click', (e) => {
                e.stopPropagation();
              });

              const infoRow = document.createElement('div');
              infoRow.className = 'weight-info-row';

              const info = document.createElement('div');
              info.className = 'weight-info';

              const label = document.createElement('span');
              label.className = 'weight-label';
			  
			  if(variant.correctedWeight.includes("Smalls"))
				  label.innerHTML = `${variant.correctedWeight.split(" ")[0]} <ss style="font-size:0.9vh;">${variant.correctedWeight.split(" ")[1]}</ss>`;
			  else if(variant.correctedWeight.includes("Other"))
				label.textContent = variant.option1;
			  else
				label.textContent = variant.correctedWeight;

              const price = document.createElement('span');
              price.className = 'weight-price';
			  
              price.textContent = `$${variant.price}`;

              info.appendChild(label);
              info.appendChild(price);
              infoRow.appendChild(info);

              const stockBadge = document.createElement('span');
              stockBadge.className = `stock-badge ${variant.available ? 'in-stock-badge' : 'out-of-stock-badge'}`;
              stockBadge.textContent = variant.available ? 'In Stock' : 'Out of Stock';

              row.appendChild(infoRow);
              row.appendChild(stockBadge);

              if (variant.available) {
                const addButton = document.createElement('button');
                addButton.className = 'add-to-cart-button';
				switch (true) {
					case variant.correctedTier.includes("Essential"):
						addButton.style.backgroundColor = "rgba(115, 248, 113, 1)";
						addButton.style.color = "#000";
						break;
					case variant.correctedTier.includes("Preferred"):
						addButton.style.backgroundColor = "rgba(142, 113, 248, 1)";
						addButton.style.color = "#fff";
						break;
					case variant.correctedTier.includes("Supreme"):
						addButton.style.backgroundColor = "#FCD34D";
						addButton.style.color = "#000";
						break;
					case variant.correctedTier.includes("Other"):
						addButton.style.backgroundColor = "rgba(217, 13, 13, 1)";
						addButton.style.color = "#000";
						break;
					// Optional: Add a default case if needed
					// default:
					//     // Handle other tiers
					//     break;
				}
                addButton.textContent = 'Add to Cart';
                addButton.onclick = (e) => {
                  e.stopPropagation();
                  virtualCart.addItem(product, variant);
                };
                row.appendChild(addButton);
              }

              weights.appendChild(row);
            });

            section.appendChild(weights);
            container.appendChild(section);
          }
        }
      });

      return container;
    }
	
  </script>
  <!-- Settings Button -->
  
  <!-- Settings Modal -->
  <div class="modal-overlay modal-backdrop closed" id="settings-modal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title">Notification Settings</h2>
        <button class="close-modal">&times;</button>
      </div>
      <div class="modal-content-scrollable">
		  <div class="settings-section">
			<h3>Update Frequency</h3>
			<div class="settings-input-group">
			  <input type="number" id="check-interval" class="settings-input" min="1" value="5" placeholder="5">
			  <span class="settings-input-suffix">minutes</span>
			</div>
		  </div>

		  <div class="settings-section">
			<h3 style="padding-bottom:10px; border-bottom: 1px solid var(--border-glow);">Notifications</h3>
			<div style="margin-bottom: 20px;">
			  <div class="settings-checkbox">
				<input type="checkbox" id="ntfy-enabled">
				<label for="ntfy-enabled">Enable App Notifications</label>
			  </div>
			  <small style="color: var(--text-muted); display: block; margin-left: 25px;">
				Receive notifications on your phone via the Ntfy app
			  </small>
			</div>

			<div style="margin-bottom: 20px;">
			  <div class="settings-checkbox">
				<input type="checkbox" id="email-enabled">
				<label for="email-enabled">Enable Email Notifications</label>
			  </div>
			  <small style="color: var(--text-muted); display: block; margin-left: 25px;">
				Receive notifications via email
			  </small>
			</div>
			
			<div style="margin-bottom: 20px;">
			  <div class="settings-checkbox">
				<input type="checkbox" id="browser-noti-enabled">
				<label for="browser-noti-enabled">Enable In-Browser Notifications</label>
			  </div>
			  <small style="color: var(--text-muted); display: block; margin-left: 25px;">
				Receive notifications via pop-up in bottom left of browser
			  </small>
			</div>
			
			<div style="margin-top: 10px;">
			  <label for="ntfy-topic">Ntfy Topic:</label>
			  <div style="display: flex; gap: 8px; margin-bottom: 4px;">
				<input type="text" id="ntfy-topic" class="settings-input notification-input" placeholder="Enter your unique topic name" style="flex: 1;">
				<button onclick="generateRandomTopic()" style="background-color: var(--accent-secondary); color: var(--bg-primary); border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; white-space: nowrap;">
				  Generate Random
				</button>
			  </div>
			  <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
				This is your private notification channel. Required for app notifications. Use the generate button for a unique topic name.
			  </small>
			</div>

			<div style="margin-top: 10px;">
			  <label for="ntfy-email">Email Address:</label>
			  <input type="email" id="ntfy-email" class="settings-input notification-input" placeholder="your@email.com">
			  <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
				Required for email notifications.
			  </small>
			</div>

			<div style="margin-top: 10px;">
			  <label for="ntfy-server">Ntfy Server (optional):</label>
			  <input type="text" id="ntfy-server" class="settings-input notification-input" placeholder="https://ntfy.sh">
			  <small style="color: var(--text-muted); display: block; margin-bottom: 10px;">
				Leave as default unless you're using a self-hosted server.
			  </small>
			</div>

			<button id="test-ntfy" onclick="testNtfyNotification()" style="background-color: var(--accent-primary); color: var(--bg-primary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">
			  Test Notifications
			</button>

			<div style="margin-top: 15px; padding: 10px; background: var(--bg-elevated); border-radius: 4px;">
			  <p style="margin: 0 0 10px 0; color: var(--text-secondary);">To receive app notifications:</p>
			  <ol style="margin: 0; padding-left: 20px; color: var(--text-muted);">
				<li>Download the Ntfy app for <a href="https://apps.apple.com/us/app/ntfy/id1625396347" target="_blank" style="color: var(--accent-primary);">iOS</a> or <a href="https://play.google.com/store/apps/details?id=io.heckel.ntfy" target="_blank" style="color: var(--accent-primary);">Android</a></li>
				<li>Open the app and tap "Add subscription"</li>
				<li>Enter your topic name exactly as above</li>
				<li>Save and wait for notifications!</li>
			  </ol>
			</div>
		  </div>

		  <div class="settings-section">
		  
			<h3 style="padding-bottom:10px; border-bottom: 1px solid var(--border-glow);">Product Filters</h3>
			<label for="notification-tier">Select Tiers (hold Ctrl/Cmd to select multiple):</label>
			<br>
			<select id="notification-tier" class="settings-select" multiple>
			  <option value="all">All Tiers</option>
			  <option value="Essential">Essential</option>
			  <option value="Preferred">Preferred</option>
			  <option value="Supreme">Supreme</option>
			</select>
			<br>
			<label for="notification-weight">Select Weights (hold Ctrl/Cmd to select multiple):</label>
			<br>
			<select id="notification-weight" class="settings-select" multiple>
			  <option value="all">All Weights</option>
			  <option value="28g">28g</option>
			  <option value="3.5g">3.5g</option>
			</select>
			<br>
			<div class="settings-checkbox">
			  <input type="checkbox" id="notify-new" checked>
			  <label for="notify-new">Notify for new products</label>
			</div>

			<div class="settings-checkbox">
			  <input type="checkbox" id="notify-stock" checked>
			  <label for="notify-stock">Notify for stock changes</label>
			</div>

			<div class="settings-checkbox">
			  <input type="checkbox" id="notify-removed" checked>
			  <label for="notify-removed">Notify for removed products</label>
			</div>
		  </div>

		  <div class="settings-section">
			<h3 style="padding-bottom:10px; border-bottom: 1px solid var(--border-glow);">Specific Products</h3>
			<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
			  <span id="products-selected-count" style="color: var(--text-muted);">0 products selected</span>
			  <button id="deselect-all-products" onclick="deselectAllProducts()" style="background: none; border: none; color: var(--accent-primary); cursor: pointer; font-size: 0.9em;">
				Deselect All
			  </button>
			</div>
			<div class="product-search">
			  <input type="text" id="product-search" placeholder="Search products...">
			</div>
			<div class="product-select-container" id="product-select">
			  <!-- Product checkboxes will be dynamically added here -->
			</div>
		  </div>
	  </div>
      <button class="save-settings">Save Settings</button>
    </div>
  </div>

  <div class="fab-container">
    <button id="settings-button" title="Settings">
      <svg class="fab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <circle cx="12" cy="12" r="3"></circle>
        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
      </svg>
    </button>

    <button id="virtual-cart-button" title="View Cart">
      <svg class="fab-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <circle cx="9" cy="21" r="1"></circle>
        <circle cx="20" cy="21" r="1"></circle>
        <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
      </svg>
	  <span class="cart-count" id="cart-item-count">0</span>
    </button>
	<!-- Theme Toggle Button -->
	
<button id="theme-editor-fab" class="fab" aria-label="Theme Editor" title="Theme Editor">
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 15 15" fill="currentColor">
    <path d="M14.8536 0.146458C15.0137 0.306636 15.0462 0.554489 14.9327 0.75053L11.0919 7.38473L7.61529 3.90815L14.2495 0.0672985C14.4455 -0.0461989 14.6934 -0.0137194 14.8536 0.146458Z" fill="currentColor"/>
<path d="M6.71962 4.4267L4.74949 5.5673C4.61505 5.64513 4.52443 5.78102 4.50424 5.93505C4.48406 6.08907 4.53661 6.24372 4.64645 6.35356L8.64645 10.3536C8.75629 10.4634 8.91095 10.516 9.06497 10.4958C9.21899 10.4756 9.35489 10.385 9.43272 10.2505L10.5733 8.2804L6.71962 4.4267Z" fill="currentColor"/>
<path d="M0.990239 10.4411C1.36415 9.12348 2.56732 8.21423 3.93696 8.21423H4.00003C5.65688 8.21423 7.00003 9.55738 7.00003 11.2142V11.2671C7.00003 12.8948 5.68055 14.2142 4.0529 14.2142H3.97308C3.58727 14.2142 3.20631 14.1282 2.85797 13.9623C2.35145 13.7211 1.75543 13.764 1.28865 14.0752L0.77738 14.416C0.603104 14.5322 0.374884 14.5275 0.205597 14.4041C0.036311 14.2808 -0.0381583 14.065 0.0190225 13.8635L0.990239 10.4411Z" fill="currentColor"/>
	</svg>
</button>
	<button id="theme-toggle" aria-label="Toggle Theme" title="Toggle Theme">
		<svg id="sun-icon" class="theme-mode-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
			<circle cx="12" cy="12" r="5"/>
			<line x1="12" y1="1" x2="12" y2="3"/>
			<line x1="12" y1="21" x2="12" y2="23"/>
			<line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
			<line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
			<line x1="1" y1="12" x2="3" y2="12"/>
			<line x1="21" y1="12" x2="23" y2="12"/>
			<line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
			<line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
		</svg>
	</button>
	
  </div>

  <!-- Cart Modal -->
  
  <div id="cart-modal" class="modal-overlay modal-backdrop closed">
    <div class="modal">
    <div class="cart-modal-content">
      <div class="modal-header">
        <h2 class="modal-title">Shopping Cart</h2>
        <button class="close-modal" onclick="closeCartModal()">&times;</button>
      </div>
      <div id="cart-items">
        <!-- Cart items will be dynamically inserted here -->
      </div>
      <div class="cart-total">
        Total: $<span id="cart-total">0.00</span>
      </div>
      <button id="checkout-button" class="checkout-button" onclick="checkout()">
        Proceed to Checkout
      </button>
    </div>
	</div>
  </div>
  



<div id="weight-filter-dropdown" class="dropdown-content glass-element fixed-dropdown">
    <ul id="weight-checkbox-list">
		<li><label>
			<input type="checkbox" value="28g" class="weight-checkbox"> 
			28g
        </label></li>
		<li><label>
			<input type="checkbox" value="28g (Smalls)" class="weight-checkbox"> 
			28g (Smalls)
        </label></li>
		<li><label>
			<input type="checkbox" value="3.5g" class="weight-checkbox"> 
			3.5g
		</label></li>
	</ul>
    <div class="dropdown-actions">
        <button class="clear-selection">Clear</button>
        <button class="apply-filters">Apply</button>
    </div>
</div>

<script>



    // Initialize Theme Toggling and Persistence
    document.addEventListener('DOMContentLoaded', () => {
        const themeToggle = document.getElementById('theme-toggle');

        // 1. Theme Toggle Click Listener
        themeToggle.addEventListener('click', () => {
            // Check if the light theme is currently active
            const isLight = document.documentElement.classList.contains('light');
            // Determine the new theme
            const newTheme = isLight ? 'dark' : 'light';
            
            applyTheme(newTheme);
        });

        // 2. Load Saved Theme on Startup
        // Get saved theme or default to 'dark'
        const savedTheme = localStorage.getItem('theme') || 'dark';
        applyTheme(savedTheme);
    });
/* --- Weight Checkbox Dropdown Handlers (Absolute Position + Scroll Fix) --- */
function setupWeightDropdown() {
    const toggleButton = document.getElementById('weight-dropdown-toggle');
    const dropdownContent = document.getElementById('weight-filter-dropdown');
    const weightList = document.getElementById('weight-checkbox-list');
    const applyButton = dropdownContent.querySelector('.apply-filters');
    const clearButton = dropdownContent.querySelector('.clear-selection');

    applyButton.addEventListener('click', (e) => {
      //updateSelectStyle(e.target);
      filterProducts();
      saveFilterState();
    });
    function positionDropdown() {
        const rect = toggleButton.getBoundingClientRect();
        
        // Calculate position relative to the document (Page Offset)
        const topPosition = rect.top + window.scrollY;
        const leftPosition = rect.left + window.scrollX;
        
        // Set the dropdown's position using position: absolute coordinates
        // rect.height + 8px for margin
        dropdownContent.style.top = `${topPosition + rect.height + 8}px`; 
        dropdownContent.style.left = `${leftPosition}px`;
    }

    function openWeightDropdown() {
        toggleButton.setAttribute('aria-expanded', 'true');
        dropdownContent.classList.add('visible');
        positionDropdown(); // Set position on open
        // Re-position on scroll if open
        window.addEventListener('scroll', positionDropdown); 
    }

    function closeWeightDropdown() {
        toggleButton.setAttribute('aria-expanded', 'false');
        dropdownContent.classList.remove('visible');
        window.removeEventListener('scroll', positionDropdown); // Remove listener on close
    }

    // 1. Toggle Dropdown Visibility
    toggleButton.addEventListener('click', (e) => {
        e.stopPropagation();
        const isExpanded = toggleButton.getAttribute('aria-expanded') === 'true';
        if (isExpanded) {
            closeWeightDropdown();
        } else {
            openWeightDropdown();
        }
    });

    // Close dropdown if clicked outside
    document.addEventListener('click', (e) => {
        if (!dropdownContent.contains(e.target) && e.target !== toggleButton) {
            closeWeightDropdown();
        }
    });

    // 2. Clear Selections... (Logic remains the same)
    clearButton.addEventListener('click', (e) => {
        e.stopPropagation();
        weightList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.checked = false;
        });
        updateWeightToggleText();
    });

    // 3. Apply Filters and Close... (Logic remains the same)
    applyButton.addEventListener('click', (e) => {
        e.stopPropagation();
        // ... (Your filter logic remains here) ...
        updateWeightToggleText();
        closeWeightDropdown();
    });
    
    // 4. Update the Toggle Button text... (Logic remains the same)
    function updateWeightToggleText() {
        const selectedCount = weightList.querySelectorAll('input[type="checkbox"]:checked').length;
        if (selectedCount > 0) {
            toggleButton.firstChild.textContent = `Weight (${selectedCount})`;
        } else {
            toggleButton.firstChild.textContent = 'Weight';
        }
    }
    
    weightList.addEventListener('change', updateWeightToggleText);
    updateWeightToggleText(); 
}
 setupWeightDropdown();
 
// --- Function to Populate the NEW Weight Checkbox Dropdown ---
function populateWeightCheckboxes(uniqueWeights) {
    const weightList = document.getElementById('weight-checkbox-list');
    
    // Clear any existing items in the list
    weightList.innerHTML = ''; 

    // Loop through your unique weights array
    uniqueWeights.forEach(weight => {
        const listItem = document.createElement('li');
        
        // Use a <label> wrapper for accessibility (clicking the text checks the box)
        // Ensure the input type is "checkbox" and the value is the weight string
        listItem.innerHTML = `
            <label>
                <input type="checkbox" value="${weight}" class="weight-checkbox"> 
                ${weight}
            </label>`;
            
        weightList.appendChild(listItem);
    });
    
    // After populating, update the toggle text (if setupWeightDropdown is defined)
    if (typeof updateWeightToggleText === 'function') {
         updateWeightToggleText();
    }
}

// NOTE: You must call this function after fetching and processing your product data!
// Example call: populateWeightCheckboxes(myArrayOfUniqueWeights);

</script>
<script>
    // ... your existing JavaScript code ...

    // NEW: Filter Toggle Open/Close Logic
			let firstStart = true;
    document.addEventListener('DOMContentLoaded', () => {
        const filterContainer = document.getElementById('filters-container');
        const header = document.getElementById('filterstohide');
        const toggleButton = document.getElementById('filter-toggle-button');
        
        if (filterContainer && toggleButton) {
            
            // Utility function to check if the screen size matches the mobile breakpoint
            function isMobile() {
                return window.matchMedia("(max-width: 1250px)").matches;
            }

            // 1. Initialize state: Close filters by default on browser
            if (!isMobile()) {
                filterContainer.classList.add("filters-closed");
                toggleButton.setAttribute('aria-expanded', 'false');
				toggleButton.innerHTML = toggleButton.innerHTML.replace("Hide Filters", "Show Filters");
            }
			else
			{
				
			}
// 2. Click Handler
            toggleButton.addEventListener('click', () => {
                // Toggles the class that triggers the CSS max-height/opacity animation
                let isClosed = toggleButton.getAttribute('aria-expanded');
                if(isClosed == 'true') {
					header.style.display = "none";
					//toggleButton.setAttribute('aria-expanded', 'true');
					filterContainer.classList.add("filters-closed");
					toggleButton.setAttribute('aria-expanded', 'false');
					toggleButton.innerHTML = toggleButton.innerHTML.replace("Hide Filters", "Show Filters");
				}
				else {
					//toggleButton.setAttribute('aria-expanded', 'false');
					header.style.display = "block";
                    filterContainer.classList.remove('filters-closed');
					toggleButton.setAttribute('aria-expanded', 'true');
					toggleButton.innerHTML = toggleButton.innerHTML.replace("Show Filters", "Hide Filters");
				
				}
				console.log('aria: ' + isClosed);
                // Update accessibility attribute
            });
            // 3. Re-evaluate on window resize (to handle switching between desktop/mobile)
            let checkInitialState = null;
            window.addEventListener('resize', () => {
				 let isClosed = toggleButton.getAttribute('aria-expanded');
                clearTimeout(checkInitialState);
                checkInitialState = setTimeout(() => {
                    if (!isMobile() && isClosed) {
                        // Ensure filters are open on desktop view
						header.style.display = "block";
						filterContainer.classList.remove('filters-closed');
						toggleButton.setAttribute('aria-expanded', 'true');
						toggleButton.innerHTML = toggleButton.innerHTML.replace("Show Filters", "Hide Filters");
                        // Apply closed state if entering mobile view
                    }
                }, 200); // Debounce for performance
            });
        }
    });

    // ... your existing JavaScript code ...
</script>

	<div id="theme-editor-modal" class="modal-backdrop">
    <div class="modal">
        <div class="modal-header">
            <h2>Theme Editor</h2>
            <button id="close-modal-button" class="modal-close-btn">&times;</button>
        </div>
        <div class="modal-content">
            <div class="theme-switch-container">
                <label for="theme-selector">Editing Theme:</label>
                <select id="theme-selector">
                    <option value="dark">Dark Theme</option>
                    <option value="light">Light Theme</option>
                </select>
            </div>
            <div id="color-inputs-container" class="color-inputs-grid">
                </div>
        </div>
        <div class="modal-footer">
            <button id="apply-theme-button" class="action-button primary-button">Apply & Save Changes</button>
            <button id="reset-theme-button" class="action-button secondary-button">Reset Current Theme</button>
        </div>
    </div>
</div>

    <script>
    const modal = document.getElementById('theme-editor-modal');
    const fab = document.getElementById('theme-editor-fab');
    const closeModalBtn = document.getElementById('close-modal-button');
    const applyBtn = document.getElementById('apply-theme-button');
    const resetBtn = document.getElementById('reset-theme-button');
    const themeSelector = document.getElementById('theme-selector');
/*
            NOTIFICATION MODULE: JAVASCRIPT LOGIC (COPY THIS)
            This script initializes the system and exposes the showNotification function globally.
        */

        // --- MODULE GLOBAL STATE ---
        let activeNotificationTimeouts = [];
        let notificationCounter = 0;
        const NOTIFICATION_DURATION = 5000; // Default duration in milliseconds

        /**
         * Creates and styles the visual DOM element for a notification.
         */
        function createNotificationElement(message, counter, title) {
            const el = document.createElement('div');
            el.id = 'notification-' + counter;
            
            // Uses the custom CSS class
            el.className = 'notification-item';
            
            // Inner content using inline or basic styles
            el.innerHTML = `
                <div style="font-weight: 600; color: var(--text-secondary);">${title}</div>
                <pre style="max-height:300px; overflow-x: hidden; overflow-y: auto; white-space: pre; color: var(--text-muted); margin-top: 0.8rem;">${message}</pre>
                <button onclick="window.cancelNotificationByID(${counter})" 
                        class="notification-close-btn">
                    &times;
                </button>
            `;
            return el;
        }

        /**
         * Hides the notification, clears its timeout, removes it from the list, and deletes it from the DOM.
         * @param {number} notificationID - The unique counter ID of the notification to be removed.
         * @param {boolean} isManual - True if removal was triggered by user or cancelAll.
         */
        function removeNotification(notificationID, isManual = false) {
            const index = activeNotificationTimeouts.findIndex(item => item.counter === notificationID);

            if (index === -1) {
                return; // Already removed or cleared
            }

            const item = activeNotificationTimeouts[index];
            const domElement = item.element;

            // 1. Visually hide the notification by removing the 'visible' class
            // This triggers the CSS slide-out transition back to the initial state
            domElement.classList.remove('visible');

            // 2. Schedule the DOM element removal after the transition (300ms)
            setTimeout(() => {
                domElement.remove();
            }, 300);

            // 3. Clean up the tracking list and clear the timeout if it hasn't expired
            if (isManual) {
                clearTimeout(item.id);
                console.log(`[CANCELLED]: Notification #${item.counter} manually stopped.`);
            } else {
                console.log(`[CLEARED]: Notification #${item.counter} (Auto-clear).`);
            }
            
            // Remove the entry from the tracking list
            activeNotificationTimeouts.splice(index, 1);
        }

        /**
         * GLOBAL FUNCTION: Schedules a new notification to appear.
         * Use this function to show alerts in your application.
         * @param {string} message - The content of the notification.
         * @param {number} [duration=5000] - The duration in milliseconds before it clears.
         */
        window.showNotification = function(message, duration = NOTIFICATION_DURATION, title = "Information") {
			if(!currentSettings.inBrowserNotificationsEnabled && title != "Error")
				return;
            notificationCounter++;
            const currentID = notificationCounter;
            const container = document.getElementById('notification-container');

            if (!container) {
                console.error("Notification container not found. Ensure the HTML structure is included in your body.");
                return;
            }
            
            // 1. Create and append the element
            const notificationElement = createNotificationElement(message, currentID, title);
            container.appendChild(notificationElement);

            // 2. Use a slight delay to trigger the CSS transition (slide in)
            setTimeout(() => {
                // Add the 'visible' class to trigger the transition from off-screen
                notificationElement.classList.add('visible');
            }, 100);
            
            // 3. Schedule the automatic removal
            const timeoutID = setTimeout(() => {
                removeNotification(currentID, false);
            }, duration);

            // 4. Store the item
            activeNotificationTimeouts.push({
                id: timeoutID,
                counter: currentID,
                element: notificationElement
            });
            
            console.log(`[SCHEDULED]: Notification #${currentID} set to clear in ${duration / 1000}s. Active: ${activeNotificationTimeouts.length}`);
        }

        /**
         * GLOBAL FUNCTION: Used by the 'x' button on notifications to cancel the timer and close the alert.
         * @param {number} notificationID - The ID of the notification to cancel.
         */
        window.cancelNotificationByID = function(notificationID) {
            removeNotification(notificationID, true);
        }
        
        /**
         * GLOBAL FUNCTION: Clears all active timeouts and immediately removes all notifications.
         */
        window.cancelAllNotifications = function() {
            if (activeNotificationTimeouts.length === 0) {
                console.warn("--- No active notifications to clear ---");
                return;
            }

            console.log("--- Manually Clearing All Notifications (Total: " + activeNotificationTimeouts.length + ") ---");

            // Iterate over a copy to safely modify the original array during the loop
            [...activeNotificationTimeouts].forEach(item => {
                removeNotification(item.counter, true);
            });
        }
        
/* ====================================================================
   THEME EDITOR LOGIC (v2.0 - Supports Color and Unit/String Variables)
   ==================================================================== */

const THEME_STORAGE_KEY = 'litFarmsCustomTheme';
// Define ALL editable variables with their type and default values.
// 'default' for colors is the opaque HEX equivalent for the color picker.
// 'applyFormat' for colors specifies how the final CSS value should be constructed (using R, G, B placeholders).
const THEME_VAR_DEFAULTS = {
    // Dark Theme (:root) - Full Definition
    'dark': {
        /* Core Palette (Colors) */
        '--bg-primary': { type: 'color', default: '#000000' },
        '--bg-secondary': { type: 'color', default: '#0A121A', applyFormat: 'rgba(R, G, B, 0.4)' }, // 40% opacity
        '--bg-elevated': { type: 'color', default: '#141E28', applyFormat: 'rgba(R, G, B, 0.6)' },  // 60% opacity
        '--bg-accent-gradient': { type: 'color', default: '#1A202C' },

        /* Accent Palette (Colors) */
        '--accent-primary': { type: 'color', default: '#38BDF8' },
        '--accent-secondary': { type: 'color', default: '#4A5568' },
        '--accent-tertiary': { type: 'color', default: '#0EA5E9' },

        /* Text Palette (Colors) */
        '--text-primary': { type: 'color', default: '#E2E8F0' },
        '--text-secondary': { type: 'color', default: '#94A3B8' },
        '--text-muted': { type: 'color', default: '#72819c' },

        /* Status & Strain Palette (Colors) */
        '--status-success': { type: 'color', default: '#48BB78' },
        '--status-error': { type: 'color', default: '#F87171' },
        '--strain-sativa': { type: 'color', default: '#969612' },
        '--strain-indica': { type: 'color', default: '#57549c' },
        '--strain-hybrid': { type: 'color', default: '#129687' },
        '--strain-unknown': { type: 'color', default: '#4A5568' },
        
        /* Effects & Overlays (Colors/Opacity) */
        '--shadow-color': { type: 'color', default: '#000000', applyFormat: 'rgba(R, G, B, 0.9)' }, // 90% opacity
        '--modal-overlay': { type: 'color', default: '#000000', applyFormat: 'rgba(R, G, B, 0.95)' }, // 95% opacity
        '--border-glow': { type: 'color', default: '#4A5568', applyFormat: 'rgba(R, G, B, 0.4)' }, // 40% opacity

        /* Layout & Motion (Units/Strings) */
        '--radius-lg': { type: 'unit', default: '14px' },
        '--blur-amount': { type: 'unit', default: '8px' },
    },
    // Light Theme (html[data-theme='light'])
    'light': {
        /* Core Palette (Colors) */
        '--bg-primary': { type: 'color', default: '#dce9fc' },
        '--bg-secondary': { type: 'color', default: '#FFFFFF', applyFormat: 'rgba(R, G, B, 0.6)' }, // 60% opacity
        '--bg-elevated': { type: 'color', default: '#FFFFFF', applyFormat: 'rgba(R, G, B, 0.85)' }, // 85% opacity
        '--bg-accent-gradient': { type: 'color', default: '#dbeafe' },

        /* Accent Palette (Colors) */
        '--accent-primary': { type: 'color', default: '#007aff' },
        '--accent-secondary': { type: 'color', default: '#4fd8ff' },
        '--accent-tertiary': { type: 'color', default: '#155fa8' },

        /* Text Palette (Colors) */
        '--text-primary': { type: 'color', default: '#0b1220' },
        '--text-secondary': { type: 'color', default: '#344154' },
        '--text-muted': { type: 'color', default: '#6b7280' },

        /* Status & Strain Palette (Colors) */
        '--status-success': { type: 'color', default: '#48BB78' },
        '--status-error': { type: 'color', default: '#F87171' },
        '--strain-sativa': { type: 'color', default: '#969612' },
        '--strain-indica': { type: 'color', default: '#57549c' },
        '--strain-hybrid': { type: 'color', default: '#129687' },
        '--strain-unknown': { type: 'color', default: '#4A5568' },

        /* Effects & Overlays (Colors/Opacity) */
        // Note: The shadow-normal and shadow-hover strings cannot be directly edited via this system
        '--shadow-color': { type: 'color', default: '#0A0F19', applyFormat: 'rgba(R, G, B, 0.15)' }, // Opaque HEX of (10, 15, 25)
        '--border-glow': { type: 'color', default: '#007aff', applyFormat: 'rgba(R, G, B, 0.25)' }, // Opaque HEX of (0, 122, 255)
        '--modal-overlay': { type: 'color', default: '#0A0A0A', applyFormat: 'rgba(R, G, B, 0.2)' }, // Opaque HEX of (10, 10, 10)

        /* Layout & Motion (Units/Strings) */
        '--radius-lg': { type: 'unit', default: '14px' },
        '--blur-amount': { type: 'unit', default: '8px' },
    }
};

let customThemeSettings = {};
let currentEditingTheme = 'dark'; 

/**
 * Converts a HEX color string to an RGB object.
 */
function hexToRgb(hex) {
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
    });

    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

/**
 * Loads custom theme settings from localStorage.
 */
function loadCustomTheme() {
    const saved = localStorage.getItem(THEME_STORAGE_KEY);
    customThemeSettings = saved ? JSON.parse(saved) : {};
}

/**
 * Applies all saved or provided custom theme settings to the live page.
 * NOTE: Updated to handle new structured defaults and complex RGBA values.
 */
function applyTheme(settings = customThemeSettings) {
    // Check if settings object is empty and clear overrides if needed (removed for brevity but assumed functional)
    if (Object.keys(settings).length === 0 || (!settings['dark'] && !settings['light'])) {
        // ... (clear overrides logic) ...
        const allVars = new Set([...Object.keys(THEME_VAR_DEFAULTS.dark), ...Object.keys(THEME_VAR_DEFAULTS.light)]);
        allVars.forEach(varName => {
            document.documentElement.style.removeProperty(varName);
        });
        const lightThemeStyle = document.getElementById('custom-light-theme-vars');
        if (lightThemeStyle) lightThemeStyle.textContent = '';
        return;
    }


    // 1. Apply Dark Theme overrides (applied to :root/document.documentElement)
    const darkVars = settings['dark'] || {};
    const darkDefaults = THEME_VAR_DEFAULTS.dark;

    for (const varName in darkDefaults) {
        const defaultDef = darkDefaults[varName];
        let value = darkVars[varName];
        
        // If no custom value, check if we need to remove a previously applied custom property
        if (!value || value.toUpperCase() === defaultDef.default.toUpperCase()) {
            document.documentElement.style.removeProperty(varName);
            continue;
        }

        let finalValue = value;

        if (defaultDef.type === 'color' && defaultDef.applyFormat) {
            // Apply transparency/special format for rgba variables
            const rgb = hexToRgb(value);
            if (rgb) {
                 finalValue = defaultDef.applyFormat.replace('R', rgb.r).replace('G', rgb.g).replace('B', rgb.b);
            } else {
                finalValue = value; // Fallback to raw hex if parsing fails
            }
        }
        
        document.documentElement.style.setProperty(varName, finalValue);
    }
    
    // 2. Apply Light Theme overrides (via a custom <style> block for 'html[data-theme="light"]')
    const lightVars = settings['light'] || {};
    const lightDefaults = THEME_VAR_DEFAULTS.light;
    let lightThemeStyle = document.getElementById('custom-light-theme-vars');
    let cssContent = "html[data-theme='light'] {\n";

    for (const varName in lightDefaults) {
        const defaultDef = lightDefaults[varName];
        let value = lightVars[varName];
        
        // If no custom value or value is default, skip adding to CSS block
        if (!value || value.toUpperCase() === defaultDef.default.toUpperCase()) {
            // Remove property in case it was set inline by a previous custom setting
            document.documentElement.style.removeProperty(varName); 
            continue;
        }

        let finalValue = value; 
        // NOTE: For simplicity, assuming light theme has no complex RGBA for now.
        
        cssContent += `  ${varName}: ${finalValue};\n`;
        // Apply immediately to the root if the light theme is currently active for live rendering
        if (document.documentElement.getAttribute('data-theme') === 'light' || document.documentElement.getAttribute('data-theme') === 'light-preview') {
            document.documentElement.style.setProperty(varName, finalValue);
        }
    }
    cssContent += "}\n";

    if (Object.keys(lightVars).length > 0) {
        if (!lightThemeStyle) {
            const newStyle = document.createElement('style');
            newStyle.id = 'custom-light-theme-vars';
            document.head.appendChild(newStyle);
            lightThemeStyle = newStyle;
        }
        lightThemeStyle.textContent = cssContent;
    } else if (lightThemeStyle) {
        lightThemeStyle.textContent = '';
    }
}

/**
 * Renders the color and unit input grid for the current editing theme.
 */
function renderColorInputs() {
    // Check console for this message on every theme switch
    console.log(`[Theme Editor] START Rendering inputs for: ${currentEditingTheme} theme.`); 

    const container = document.getElementById('color-inputs-container');
    // CRITICAL: Ensures all previous input elements are destroyed
    container.innerHTML = ''; 
    
    const variables = THEME_VAR_DEFAULTS[currentEditingTheme];
    const currentCustomVars = customThemeSettings[currentEditingTheme] || {};

    if (!variables) {
        console.error(`[Theme Editor ERROR] No variables found for theme: ${currentEditingTheme}`);
        return;
    }

    // Use Object.entries for a safer, explicit iteration over the variable keys
    Object.entries(variables).forEach(([varName, defaultDef]) => { 
        
        // This log should appear for every variable successfully processed
        console.log(`[Theme Editor] Processing: ${varName}`); 

        // Get the value to display: custom value, or default value
        let currentValue = currentCustomVars[varName] || defaultDef.default;
        const isColor = defaultDef.type === 'color';

        const group = document.createElement('div');
        group.className = 'color-group';
        
        // Convert varName to a more readable label
        const labelText = varName.replace(/--/g, '').replace(/-/g, ' ').split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

        if (isColor) {
            // For color inputs, we use a color picker and a text input for HEX
            group.innerHTML = `
                <label for="${varName}-${currentEditingTheme}">${labelText} (Color)</label>
                <div class="color-input-wrapper">
                    <input type="color" id="picker-${varName}" value="${currentValue}">
                    <input type="text" id="text-${varName}" value="${currentValue}" data-var="${varName}" maxlength="7">
                </div>
            `;
        } else {
             // For unit/string inputs, we use only a text input
             group.innerHTML = `
                <label for="${varName}-${currentEditingTheme}">${labelText} (Unit)</label>
                <div class="color-input-wrapper">
                    <input type="text" id="text-${varName}" value="${currentValue}" data-var="${varName}">
                </div>
            `;
        }
        
        const textInput = group.querySelector(`#text-${varName}`);
        const colorPicker = group.querySelector(`#picker-${varName}`);
        
        // Live Update on Input Change - (omitted for brevity, but should be attached here)
        const updateHandler = (e) => {
            let value = e.target.value.trim();
            
            if (isColor) {
                const isPicker = e.target.type === 'color';
                value = (isPicker ? e.target.value : value.toUpperCase());
                
                if (isPicker) {
                    textInput.value = value;
                } else if (!/^#([0-9A-F]{3}){1,2}$/i.test(value)) {
                    value = colorPicker ? colorPicker.value : value;
                } else if (colorPicker) {
                    colorPicker.value = value;
                }
            }
            document.documentElement.style.setProperty(varName, value || '');
        };

        if (colorPicker) colorPicker.addEventListener('input', updateHandler);
        textInput.addEventListener('input', updateHandler);

        container.appendChild(group);
    }); 
	
    console.log(`[Theme Editor] END Rendering inputs for: ${currentEditingTheme} theme.`); // DEBUG LOG
}

/**
 * Collects values from the inputs, saves them to localStorage, and applies them permanently.
 * NOTE: Updated for the new defaults structure.
 */
function saveAndApplyChanges() {
    const container = document.getElementById('color-inputs-container');
    const inputs = container.querySelectorAll('input[type="text"][data-var]');
    
    customThemeSettings[currentEditingTheme] = {};
    const defaults = THEME_VAR_DEFAULTS[currentEditingTheme];
    
    inputs.forEach(input => {
        const varName = input.getAttribute('data-var');
        const defaultDef = defaults[varName];
        if (!defaultDef) return;

        const defaultValue = defaultDef.default;
        let newValue = input.value.trim();

        // Check if value is different from default (case-insensitive for colors)
        const isDefault = defaultDef.type === 'color' ? newValue.toUpperCase() === defaultValue.toUpperCase() : newValue === defaultValue;
        
        if (newValue && !isDefault) {
            customThemeSettings[currentEditingTheme][varName] = newValue;
        }
    });

    // Save the entire settings object to localStorage
    localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(customThemeSettings));
    
    // Apply the changes to the live CSS. 
    applyTheme();

    // Reset the data-theme if it was in preview mode
    if (document.documentElement.getAttribute('data-theme') === 'light-preview') {
         document.documentElement.setAttribute('data-theme', 'light');
    }

    alert('Theme changes applied and saved to local storage!');
    document.getElementById('theme-editor-modal').classList.remove('open');
}

/**
 * Resets the currently editing theme to its default values.
 */
function resetCurrentTheme() {
    if (!confirm(`Are you sure you want to reset the ${currentEditingTheme} theme to its default colors? This will clear your custom settings for this theme.`)) {
        return;
    }

    // 1. Clear the custom settings for the current theme
    delete customThemeSettings[currentEditingTheme];
    
    // 2. Update localStorage
    localStorage.setItem(THEME_STORAGE_KEY, JSON.stringify(customThemeSettings));

    // 3. Re-apply the overall theme, which will clear the inline styles and custom <style> block
    applyTheme();
    
    // 4. Re-render inputs to show default values
    renderColorInputs();

    alert(`${currentEditingTheme} theme successfully reset.`);
}

/**
 * Event Listeners and Initialization
 */
 
document.addEventListener('DOMContentLoaded', () => {
    // 1. Load saved theme and apply it immediately on page load
    loadCustomTheme();
    applyTheme();
    

    // 2. Open Modal Handler
    fab.addEventListener('click', () => {
        const activeTheme = document.documentElement.getAttribute('data-theme') || 'dark';
        
        // Set the editor to the current active theme
        themeSelector.value = activeTheme;
        currentEditingTheme = activeTheme;

        // Set the document to 'light-preview' if it's currently 'dark' but we're editing 'light'
        if (currentEditingTheme === 'light' && activeTheme === 'dark') {
             document.documentElement.setAttribute('data-theme', 'light-preview');
			 console.log('switched to light');
        }
		else if (currentEditingTheme === 'dark' && activeTheme === 'light') {
             document.documentElement.setAttribute('data-theme', 'dark-preview');
			 console.log('switched to dark');
		}

        renderColorInputs();
        modal.classList.add('open');
    });

    // 3. Close Modal Handlers
    function closeModal() {
        modal.classList.remove('open');
        
        // Restore the live theme state by re-applying saved settings (discards unapplied live-previews)
        applyTheme(); 

        // Clear the light-preview state if needed
        // If the editor was open, we need to check if the user had the light theme saved
        const savedTheme = localStorage.getItem('theme') || 'dark'; // Get the user's previously set theme preference

        if (document.documentElement.getAttribute('data-theme') === 'light-preview') {
            // If we were in preview mode, switch the active theme back to what the user had before opening the editor
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            } else {
                document.documentElement.removeAttribute('data-theme'); // Go back to dark theme
            }
        }
    }

    closeModalBtn.addEventListener('click', closeModal);
    
    // Close modal on outside click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });


    // 5. Apply/Save Button Handler
    applyBtn.addEventListener('click', saveAndApplyChanges);

    // 6. Reset Button Handler
    resetBtn.addEventListener('click', resetCurrentTheme);
});

    // 4. Theme Selector Change Handler
    // 4. Theme Selector Change Handler (ROBUST VERSION)
    themeSelector.addEventListener('change', (e) => {
        const newEditingTheme = e.target.value;

        // Critical: Update the global state variable
        currentEditingTheme = newEditingTheme;
        
        // 1. Handle live preview switch for the entire page
        if (currentEditingTheme === 'light') {
            // Set to a temporary preview state to show light theme variables
            document.documentElement.setAttribute('data-theme', 'light');
			themeIcon.innerHTML = SUN_ICON_PATH;
			//applyTheme();
        } else if (currentEditingTheme === 'dark') {
            // Remove the data-theme attribute, which reverts the page to the default (dark) theme
            document.documentElement.removeAttribute('data-theme'); 
			themeIcon.innerHTML = MOON_ICON_PATH;
			//applyTheme();
        }
        applyTheme();
        // 2. Re-render inputs to show the correct variable list for the newly selected theme
        renderColorInputs();
    });

    // 5. Apply/Save Button Handler
    applyBtn.addEventListener('click', saveAndApplyChanges);

    // 6. Reset Button Handler
    resetBtn.addEventListener('click', resetCurrentTheme);

// ... existing variables like fab, modal, themeSelector ...

// Check if your old theme toggle button was named 'theme-toggle-button' or use its actual ID

// --- START: Core Theme Switching Logic ---
/**
 * Toggles the 'data-theme' attribute and saves the preference to localStorage.
 * IMPORTANT: It calls applyTheme() to ensure any custom colors are loaded on the new base theme.
 */
// Add the icon element to your list of variables
const themeToggleButton = document.getElementById('theme-toggle'); 
const themeIcon = document.getElementById('sun-icon'); // NEW VARIABLE

// Define the SVG paths
const MOON_ICON_PATH = '<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>';
const SUN_ICON_PATH = '<circle cx="12" cy="12" r="4"></circle><path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"></path>';

/**
 * Toggles the 'data-theme' attribute and saves the preference to localStorage.
 * IMPORTANT: It calls applyTheme() to ensure any custom colors are loaded on the new base theme.
 */
function switchTheme() {
    const root = document.documentElement;
    const currentTheme = root.getAttribute('data-theme') === 'light' ? 'light' : 'dark';
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

    // 1. Set the new theme
    if (newTheme === 'light') {
        root.setAttribute('data-theme', 'light');
    } else {
        root.removeAttribute('data-theme'); // Defaults it to dark
    }

    // 2. Update the icon
    if (themeIcon) {
        // If switching to light theme, show the sun icon (inside the SVG)
        if (newTheme === 'light') {
            themeIcon.innerHTML = SUN_ICON_PATH;
        } 
        // If switching to dark theme, show the moon icon (inside the SVG)
        else {
            themeIcon.innerHTML = MOON_ICON_PATH;
        }
    }

    // 3. Save the preference
    localStorage.setItem('theme', newTheme);
    
    // 4. Re-apply any custom overrides
    applyTheme(); 
}

// 4. Initial Theme Check (on load) - UPDATED TO SET ICON ON LOAD
const savedThemePreference = localStorage.getItem('theme');
if (savedThemePreference === 'light') {
    document.documentElement.setAttribute('data-theme', 'light');
    if (themeIcon) {
        themeIcon.innerHTML = SUN_ICON_PATH; // Set sun icon if light is default
    }
} else {
     // Ensure moon icon is set if dark is default
     if (themeIcon) {
        themeIcon.innerHTML = MOON_ICON_PATH; 
    }
}

// 5. Attach the event listener (if the button exists)
if (themeToggleButton) {
    themeToggleButton.addEventListener('click', switchTheme);
}
// --- END: Core Theme Switching Logic ---




    </script>
   
    <div id="notification-container" class="notification-container">
        <!-- Notifications will be dynamically inserted here -->
    </div>

</body>
</html>